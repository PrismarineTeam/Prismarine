From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: AlphaKR93 <alphakr93@outlook.com>
Date: Mon, 4 Jul 2022 13:08:16 +0900
Subject: [PATCH] JettPack Server Patches

Original by Simon Gardling <titaniumtown@gmail.com>

Copyright (C) JettPackMC LLC

This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation, either version 3 of the License, or (at your
option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program. If not, see <http://www.gnu.org/licenses/>.

[ADDED PATCHES]
0003
0005
0008
0009
0011
0012
0013
0014
0017
0020
0021
0022
0023
0027
0028
0029
0031
0035
0038
0040
0041
0042
0043
0044
0045
0057
0058

diff --git a/src/main/java/com/destroystokyo/paper/util/maplist/IBlockDataList.java b/src/main/java/com/destroystokyo/paper/util/maplist/IBlockDataList.java
index 277cfd9d1e8fff5d9b5e534b75c3c5162d58b0b7..c8e5798f8d9a77f5f8552c3663b4d95eff77b5fb 100644
--- a/src/main/java/com/destroystokyo/paper/util/maplist/IBlockDataList.java
+++ b/src/main/java/com/destroystokyo/paper/util/maplist/IBlockDataList.java
@@ -26,7 +26,7 @@ public final class IBlockDataList {
     private int size;
 
     public static int getLocationKey(final int x, final int y, final int z) {
-        return (x & 15) | (((z & 15) << 4)) | ((y & 255) << (4 + 4));
+        return (x & 15) | ((z & 15) << 4) | ((y & 4095) << 8); // Prismarine - JettPack patches (0058)
     }
 
     public static BlockState getBlockDataFromRaw(final long raw) {
diff --git a/src/main/java/com/ishland/c2me/opts/allocs/common/ObjectCachingUtils.java b/src/main/java/com/ishland/c2me/opts/allocs/common/ObjectCachingUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..35af9788a2cfc9203a9987a1a241870658feece7
--- /dev/null
+++ b/src/main/java/com/ishland/c2me/opts/allocs/common/ObjectCachingUtils.java
@@ -0,0 +1,23 @@
+package com.ishland.c2me.opts.allocs.common;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+
+import java.util.BitSet;
+import java.util.function.IntFunction;
+
+public class ObjectCachingUtils {
+
+    private static final IntFunction<BitSet> bitSetConstructor = BitSet::new;
+
+    public static ThreadLocal<Int2ObjectOpenHashMap<BitSet>> BITSETS = ThreadLocal.withInitial(Int2ObjectOpenHashMap::new);
+
+    private ObjectCachingUtils() {
+    }
+
+    public static BitSet getCachedOrNewBitSet(int bits) {
+        final BitSet bitSet = BITSETS.get().computeIfAbsent(bits, bitSetConstructor);
+        bitSet.clear();
+        return bitSet;
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/io/papermc/paper/util/MCUtil.java b/src/main/java/io/papermc/paper/util/MCUtil.java
index c8f7aa9e0794713724e1053581c220aa95f1bc90..07aa7249b2a84f0441ce7d010cc39e931cb67d34 100644
--- a/src/main/java/io/papermc/paper/util/MCUtil.java
+++ b/src/main/java/io/papermc/paper/util/MCUtil.java
@@ -55,9 +55,10 @@ import java.util.function.Consumer;
 import java.util.function.Supplier;
 
 public final class MCUtil {
+    public static final java.util.concurrent.ConcurrentLinkedQueue smallAsyncTasks = new java.util.concurrent.ConcurrentLinkedQueue(); // Jettpack // Prismarine - JettPack patches
     public static final ThreadPoolExecutor asyncExecutor = new ThreadPoolExecutor(
-        0, 2, 60L, TimeUnit.SECONDS,
-        new LinkedBlockingQueue<>(),
+        4, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, // JettPack // Prismarine - JettPack patches
+        new java.util.concurrent.SynchronousQueue<Runnable>(), // JettPack // Prismarine - JettPack patches
         new ThreadFactoryBuilder()
             .setNameFormat("Paper Async Task Handler Thread - %1$d")
             .setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(MinecraftServer.LOGGER))
@@ -74,6 +75,30 @@ public final class MCUtil {
 
     public static final long INVALID_CHUNK_KEY = getCoordinateKey(Integer.MAX_VALUE, Integer.MAX_VALUE);
 
+    // Prismarine start - JettPack patches
+    public static void flushAsyncTasks() {
+        if (!smallAsyncTasks.isEmpty()) {
+            asyncExecutor.submit(() -> {
+                Runnable runnable;
+                while((runnable = (Runnable)smallAsyncTasks.poll()) != null) {
+                    runnable.run();
+                }
+            });
+        }
+    }
+
+    public static void flushAsyncTasksMidTick() {
+        int i = smallAsyncTasks.size() < 16 ? smallAsyncTasks.size() : 16; // if smallAsyncTasks is over size 16, only execute 16 tasks
+        asyncExecutor.submit(() -> {
+            Runnable runnable;
+            int i_tmp = 0;
+            while((runnable = (Runnable)smallAsyncTasks.poll()) != null && i_tmp != i-1) {
+                runnable.run();
+                i_tmp += 1;
+            }
+        });
+    }
+    // Prismarine end
 
     public static Runnable once(Runnable run) {
         AtomicBoolean ran = new AtomicBoolean(false);
diff --git a/src/main/java/me/jellysquid/mods/lithium/common/util/collections/HashedList.java b/src/main/java/me/jellysquid/mods/lithium/common/util/collections/HashedList.java
new file mode 100644
index 0000000000000000000000000000000000000000..593f429a230b5056169be4e552791f77175d10f9
--- /dev/null
+++ b/src/main/java/me/jellysquid/mods/lithium/common/util/collections/HashedList.java
@@ -0,0 +1,280 @@
+package me.jellysquid.mods.lithium.common.util.collections;
+
+import it.unimi.dsi.fastutil.objects.Reference2IntOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ReferenceArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.NoSuchElementException;
+
+/**
+ * Wraps a {@link List} with a hash table which provides O(1) lookups for {@link Collection#contains(Object)}. The type
+ * contained by this list must use reference-equality semantics.
+ */
+@SuppressWarnings("SuspiciousMethodCalls")
+public class HashedList<T> implements List<T> {
+    private final ReferenceArrayList<T> list;
+    private final Reference2IntOpenHashMap<T> counter;
+
+    public HashedList(List<T> list) {
+        this.list = new ReferenceArrayList<>();
+        this.list.addAll(list);
+
+        this.counter = new Reference2IntOpenHashMap<>();
+        this.counter.defaultReturnValue(0);
+
+        for (T obj : this.list) {
+            this.counter.addTo(obj, 1);
+        }
+    }
+
+    @Override
+    public int size() {
+        return this.list.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return this.list.isEmpty();
+    }
+
+    @Override
+    public boolean contains(Object o) {
+        return this.counter.containsKey(o);
+    }
+
+    @Override
+    public Iterator<T> iterator() {
+        return this.listIterator();
+    }
+
+    @Override
+    public Object[] toArray() {
+        return this.list.toArray();
+    }
+
+    @SuppressWarnings("SuspiciousToArrayCall")
+    @Override
+    public <T1> T1[] toArray(T1[] a) {
+        return this.list.toArray(a);
+    }
+
+    @Override
+    public boolean add(T t) {
+        this.trackReferenceAdded(t);
+
+        return this.list.add(t);
+    }
+
+    @Override
+    public boolean remove(Object o) {
+        this.trackReferenceRemoved(o);
+
+        return this.list.remove(o);
+    }
+
+    @Override
+    public boolean containsAll(Collection<?> c) {
+        for (Object obj : c) {
+            if (!this.counter.containsKey(obj)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    @Override
+    public boolean addAll(Collection<? extends T> c) {
+        for (T obj : c) {
+            this.trackReferenceAdded(obj);
+        }
+
+        return this.list.addAll(c);
+    }
+
+    @Override
+    public boolean addAll(int index, Collection<? extends T> c) {
+        for (T obj : c) {
+            this.trackReferenceAdded(obj);
+        }
+
+        return this.list.addAll(index, c);
+    }
+
+    @Override
+    public boolean removeAll(Collection<?> c) {
+        for (Object obj : c) {
+            this.trackReferenceRemoved(obj);
+        }
+
+        return this.list.removeAll(c);
+    }
+
+    @Override
+    public boolean retainAll(Collection<?> c) {
+        return this.list.retainAll(c);
+    }
+
+    @Override
+    public void clear() {
+        this.counter.clear();
+        this.list.clear();
+    }
+
+    @Override
+    public T get(int index) {
+        return this.list.get(index);
+    }
+
+    @Override
+    public T set(int index, T element) {
+        T prev = this.list.set(index, element);
+
+        if (prev != element) {
+            if (prev != null) {
+                this.trackReferenceRemoved(prev);
+            }
+
+            this.trackReferenceAdded(element);
+        }
+
+        return prev;
+    }
+
+    @Override
+    public void add(int index, T element) {
+        this.trackReferenceAdded(element);
+
+        this.list.add(index, element);
+    }
+
+    @Override
+    public T remove(int index) {
+        T prev = this.list.remove(index);
+
+        if (prev != null) {
+            this.trackReferenceRemoved(prev);
+        }
+
+        return prev;
+    }
+
+    @Override
+    public int indexOf(Object o) {
+        return this.list.indexOf(o);
+    }
+
+    @Override
+    public int lastIndexOf(Object o) {
+        return this.list.lastIndexOf(o);
+    }
+
+    @Override
+    public ListIterator<T> listIterator() {
+        return this.listIterator(0);
+    }
+
+    @Override
+    public ListIterator<T> listIterator(int index) {
+        return new ListIterator<T>() {
+            private final ListIterator<T> inner = HashedList.this.list.listIterator(index);
+
+            @Override
+            public boolean hasNext() {
+                return this.inner.hasNext();
+            }
+
+            @Override
+            public T next() {
+                return this.inner.next();
+            }
+
+            @Override
+            public boolean hasPrevious() {
+                return this.inner.hasPrevious();
+            }
+
+            @Override
+            public T previous() {
+                return this.inner.previous();
+            }
+
+            @Override
+            public int nextIndex() {
+                return this.inner.nextIndex();
+            }
+
+            @Override
+            public int previousIndex() {
+                return this.inner.previousIndex();
+            }
+
+            @Override
+            public void remove() {
+                int last = this.previousIndex();
+
+                if (last == -1) {
+                    throw new NoSuchElementException();
+                }
+
+                T prev = HashedList.this.get(last);
+
+                if (prev != null) {
+                    HashedList.this.trackReferenceRemoved(prev);
+                }
+
+                this.inner.remove();
+            }
+
+            @Override
+            public void set(T t) {
+                int last = this.previousIndex();
+
+                if (last == -1) {
+                    throw new NoSuchElementException();
+                }
+
+                T prev = HashedList.this.get(last);
+
+                if (prev != t) {
+                    if (prev != null) {
+                        HashedList.this.trackReferenceRemoved(prev);
+                    }
+
+                    HashedList.this.trackReferenceAdded(t);
+                }
+
+                this.inner.remove();
+            }
+
+            @Override
+            public void add(T t) {
+                HashedList.this.trackReferenceAdded(t);
+
+                this.inner.add(t);
+            }
+        };
+    }
+
+    @Override
+    public List<T> subList(int fromIndex, int toIndex) {
+        return this.list.subList(fromIndex, toIndex);
+    }
+
+    private void trackReferenceAdded(T t) {
+        this.counter.addTo(t, 1);
+    }
+
+    @SuppressWarnings("unchecked")
+    private void trackReferenceRemoved(Object o) {
+        if (this.counter.addTo((T) o, -1) <= 1) {
+            this.counter.removeInt(o);
+        }
+    }
+
+    public static <T> HashedList<T> wrapper(List<T> list) {
+        return new HashedList<>(list);
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/me/jellysquid/mods/lithium/common/util/math/CompactSineLUT.java b/src/main/java/me/jellysquid/mods/lithium/common/util/math/CompactSineLUT.java
new file mode 100644
index 0000000000000000000000000000000000000000..600b30b097619c76ca95a4fdb6fb17b893e25207
--- /dev/null
+++ b/src/main/java/me/jellysquid/mods/lithium/common/util/math/CompactSineLUT.java
@@ -0,0 +1,89 @@
+package me.jellysquid.mods.lithium.common.util.math;
+
+import net.minecraft.util.Mth;
+
+/**
+ * A replacement for the sine angle lookup table used in {@link Mth}, both reducing the size of LUT and improving
+ * the access patterns for common paired sin/cos operations.
+ *
+ *  sin(-x) = -sin(x)
+ *    ... to eliminate negative angles from the LUT.
+ *
+ *  sin(x) = sin(pi/2 - x)
+ *    ... to eliminate supplementary angles from the LUT.
+ *
+ * Using these identities allows us to reduce the LUT from 64K entries (256 KB) to just 16K entries (64 KB), enabling
+ * it to better fit into the CPU's caches at the expense of some cycles on the fast path. The implementation has been
+ * tightly optimized to avoid branching where possible and to use very quick integer operations.
+ *
+ * Generally speaking, reducing the size of a lookup table is always a good optimization, but since we need to spend
+ * extra CPU cycles trying to maintain parity with vanilla, there is the potential risk that this implementation ends
+ * up being slower than vanilla when the lookup table is able to be kept in cache memory.
+ *
+ * Unlike other "fast math" implementations, the values returned by this class are *bit-for-bit identical* with those
+ * from {@link Mth}. Validation is performed during runtime to ensure that the table is correct.
+ *
+ * @author coderbot16   Author of the original (and very clever) implementation in Rust:
+ *  https://gitlab.com/coderbot16/i73/-/tree/master/i73-trig/src
+ * @author jellysquid3  Additional optimizations, port to Java
+ */
+public class CompactSineLUT {
+    private static final int[] SINE_TABLE_INT = new int[16384 + 1];
+    private static final float SINE_TABLE_MIDPOINT;
+
+    static {
+        // Copy the sine table, covering to raw int bits
+        for (int i = 0; i < SINE_TABLE_INT.length; i++) {
+            SINE_TABLE_INT[i] = Float.floatToRawIntBits(Mth.SIN[i]);
+        }
+
+        SINE_TABLE_MIDPOINT = Mth.SIN[Mth.SIN.length / 2];
+
+        // Test that the lookup table is correct during runtime
+        for (int i = 0; i < Mth.SIN.length; i++) {
+            float expected = Mth.SIN[i];
+            float value = lookup(i);
+
+            if (expected != value) {
+                throw new IllegalArgumentException(String.format("LUT error at index %d (expected: %s, found: %s)", i, expected, value));
+            }
+        }
+    }
+
+    // [VanillaCopy] MathHelper#sin(float)
+    public static float sin(float f) {
+        return lookup((int) (f * 10430.38) & 0xFFFF);
+    }
+
+    // [VanillaCopy] MathHelper#cos(float)
+    public static float cos(float f) {
+        return lookup((int) (f * 10430.38 + 16384.0) & 0xFFFF);
+    }
+
+    private static float lookup(int index) {
+        // A special case... Is there some way to eliminate this?
+        if (index == 32768) {
+            return SINE_TABLE_MIDPOINT;
+        }
+
+        // Trigonometric identity: sin(-x) = -sin(x)
+        // Given a domain of 0 <= x <= 2*pi, just negate the value if x > pi.
+        // This allows the sin table size to be halved.
+        int neg = (index & 0x8000) << 16;
+
+        // All bits set if (pi/2 <= x), none set otherwise
+        // Extracts the 15th bit from 'half'
+        int mask = (index << 17) >> 31;
+
+        // Trigonometric identity: sin(x) = sin(pi/2 - x)
+        int pos = (0x8001 & mask) + (index ^ mask);
+
+        // Wrap the position in the table. Moving this down to immediately before the array access
+        // seems to help the Hotspot compiler optimize the bit math better.
+        pos &= 0x7fff;
+
+        // Fetch the corresponding value from the LUT and invert the sign bit as needed
+        // This directly manipulate the sign bit on the float bits to simplify logic
+        return Float.intBitsToFloat(SINE_TABLE_INT[pos] ^ neg);
+    }
+}
diff --git a/src/main/java/me/jellysquid/mods/lithium/common/world/chunk/LithiumHashPalette.java b/src/main/java/me/jellysquid/mods/lithium/common/world/chunk/LithiumHashPalette.java
new file mode 100644
index 0000000000000000000000000000000000000000..16debe176798f316c122e8e7aef2b50ecb9883a6
--- /dev/null
+++ b/src/main/java/me/jellysquid/mods/lithium/common/world/chunk/LithiumHashPalette.java
@@ -0,0 +1,189 @@
+package me.jellysquid.mods.lithium.common.world.chunk;
+
+import com.google.common.collect.ImmutableList;
+import it.unimi.dsi.fastutil.HashCommon;
+import it.unimi.dsi.fastutil.objects.Reference2IntMap;
+import it.unimi.dsi.fastutil.objects.Reference2IntOpenHashMap;
+import java.util.Arrays;
+import java.util.List;
+import java.util.function.Predicate;
+import net.minecraft.core.IdMap;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.world.level.chunk.Palette;
+import net.minecraft.world.level.chunk.PaletteResize;
+
+import static it.unimi.dsi.fastutil.Hash.FAST_LOAD_FACTOR;
+
+/**
+ * Generally provides better performance over the vanilla {@link net.minecraft.world.level.chunk.HashMapPalette} when calling
+ * {@link LithiumHashPalette#idFor(Object)} through using a faster backing map and reducing pointer chasing.
+ */
+public class LithiumHashPalette<T> implements Palette<T> {
+    private static final int ABSENT_VALUE = -1;
+
+    private final IdMap<T> idList;
+    private final PaletteResize<T> resizeHandler;
+    private final int indexBits;
+
+    private final Reference2IntMap<T> table;
+    private T[] entries;
+    private int size = 0;
+
+    public LithiumHashPalette(IdMap<T> idList, PaletteResize<T> resizeHandler, int indexBits, T[] entries, Reference2IntMap<T> table, int size) {
+        this.idList = idList;
+        this.resizeHandler = resizeHandler;
+        this.indexBits = indexBits;
+        this.entries = entries;
+        this.table = table;
+        this.size = size;
+    }
+
+    public LithiumHashPalette(IdMap<T> idList, int bits, PaletteResize<T> resizeHandler, List<T> list) {
+        this(idList, bits, resizeHandler);
+
+        for (T t : list) {
+            this.addEntry(t);
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    public LithiumHashPalette(IdMap<T> idList, int bits, PaletteResize<T> resizeHandler) {
+        this.idList = idList;
+        this.indexBits = bits;
+        this.resizeHandler = resizeHandler;
+
+        int capacity = 1 << bits;
+
+        this.entries = (T[]) new Object[capacity];
+        this.table = new Reference2IntOpenHashMap<>(capacity, FAST_LOAD_FACTOR);
+        this.table.defaultReturnValue(ABSENT_VALUE);
+    }
+
+    @Override
+    public int idFor(T obj) {
+        int id = this.table.getInt(obj);
+
+        if (id == ABSENT_VALUE) {
+            id = this.computeEntry(obj);
+        }
+
+        return id;
+    }
+
+    @Override
+    public boolean maybeHas(Predicate<T> predicate) {
+        for (int i = 0; i < this.size; ++i) {
+            if (predicate.test(this.entries[i])) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    private int computeEntry(T obj) {
+        int id = this.addEntry(obj);
+
+        if (id >= 1 << this.indexBits) {
+            if (this.resizeHandler == null) {
+                throw new IllegalStateException("Cannot grow");
+            } else {
+                id = this.resizeHandler.onResize(this.indexBits + 1, obj);
+            }
+        }
+
+        return id;
+    }
+
+    private int addEntry(T obj) {
+        int nextId = this.size;
+
+        if (nextId >= this.entries.length) {
+            this.resize(this.size);
+        }
+
+        this.table.put(obj, nextId);
+        this.entries[nextId] = obj;
+
+        this.size++;
+
+        return nextId;
+    }
+
+    private void resize(int neededCapacity) {
+        this.entries = Arrays.copyOf(this.entries, HashCommon.nextPowerOfTwo(neededCapacity + 1));
+    }
+
+    @Override
+    public T valueFor(int id) {
+        T[] entries = this.entries;
+
+        if (id >= 0 && id < entries.length) {
+            return entries[id];
+        }
+
+        return null;
+    }
+
+    @Override
+    public void read(FriendlyByteBuf buf) {
+        this.clear();
+
+        int entryCount = buf.readVarInt();
+
+        for (int i = 0; i < entryCount; ++i) {
+            this.addEntry(this.idList.byId(buf.readVarInt()));
+        }
+    }
+
+    @Override
+    public void write(FriendlyByteBuf buf) {
+        int size = this.size;
+        buf.writeVarInt(size);
+
+        for (int i = 0; i < size; ++i) {
+            buf.writeVarInt(this.idList.getId(this.valueFor(i)));
+        }
+    }
+
+    @Override
+    public int getSerializedSize() {
+        int size = FriendlyByteBuf.getVarIntSize(this.size);
+
+        for (int i = 0; i < this.size; ++i) {
+            size += FriendlyByteBuf.getVarIntSize(this.idList.getId(this.valueFor(i)));
+        }
+
+        return size;
+    }
+
+    @Override
+    public int getSize() {
+        return this.size;
+    }
+
+    @Override
+    public Palette<T> copy() {
+        return new LithiumHashPalette<>(this.idList, this.resizeHandler, this.indexBits, this.entries.clone(), new Reference2IntOpenHashMap<>(this.table), this.size);
+    }
+
+    private void clear() {
+        Arrays.fill(this.entries, null);
+        this.table.clear();
+        this.size = 0;
+    }
+
+    public List<T> getElements() {
+        ImmutableList.Builder<T> builder = new ImmutableList.Builder<>();
+        for (T entry : this.entries) {
+            if (entry != null) {
+                builder.add(entry);
+            }
+        }
+        return builder.build();
+    }
+
+    public static <A> Palette<A> create(int bits, IdMap<A> idList, PaletteResize<A> listener, List<A> list) {
+        return new LithiumHashPalette<>(idList, bits, listener, list);
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/me/titaniumtown/cache/NBTCache.java b/src/main/java/me/titaniumtown/cache/NBTCache.java
new file mode 100644
index 0000000000000000000000000000000000000000..6b416b201c370f497e2fd4368ffa0cdbb064a53e
--- /dev/null
+++ b/src/main/java/me/titaniumtown/cache/NBTCache.java
@@ -0,0 +1,32 @@
+package me.titaniumtown.cache;
+
+import it.unimi.dsi.fastutil.objects.Object2ObjectLinkedOpenCustomHashMap;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.nbt.CompoundTag;
+
+import java.io.File;
+
+public class NBTCache extends Object2ObjectLinkedOpenCustomHashMap<File, CompoundTag> {
+
+    public NBTCache() {
+        super(100, 0.75F, new Strategy<File>() {
+            @Override
+            public int hashCode(File k) {
+                return k.hashCode();
+            }
+
+            @Override
+            public boolean equals(File k, File k1) {
+                return k.equals(k1);
+            }
+        });
+    }
+
+    @Override
+    public CompoundTag put(File k, CompoundTag v) {
+        if (this.size() > MinecraftServer.getServer().getPlayerCount()) {
+            this.removeLast();
+        }
+        return super.putAndMoveToFirst(k, v);
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/me/titaniumtown/util/ServerWorkerWrapper.java b/src/main/java/me/titaniumtown/util/ServerWorkerWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..b45371f7a776451d5a15da03d130a32ff3d49e28
--- /dev/null
+++ b/src/main/java/me/titaniumtown/util/ServerWorkerWrapper.java
@@ -0,0 +1,24 @@
+package me.titaniumtown.util;
+
+import com.google.common.base.Preconditions;
+import net.minecraft.Util;
+
+public final class ServerWorkerWrapper implements Runnable {
+    private final Runnable internalRunnable;
+
+    public ServerWorkerWrapper(Runnable runnable) {
+        this.internalRunnable = Preconditions.checkNotNull(runnable, "internalRunnable");
+    }
+
+    @Override
+    public final void run() {
+        try {
+            this.internalRunnable.run();
+            return;
+        }
+        catch (Throwable throwable) {
+            Util.onThreadException(Thread.currentThread(), throwable);
+            return;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/Util.java b/src/main/java/net/minecraft/Util.java
index 9894a955015e9cb8138f5d12a74b4a650ce06852..80bfb4e038e8c7c3d34a7bbabdc73ebc79637239 100644
--- a/src/main/java/net/minecraft/Util.java
+++ b/src/main/java/net/minecraft/Util.java
@@ -65,9 +65,11 @@ import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
+import me.titaniumtown.util.ServerWorkerWrapper; // Prismarine - JettPack patches
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.Bootstrap;
 import net.minecraft.util.Mth;
+import io.papermc.paper.util.MCUtil; // Prismarine - JettPack patches
 import net.minecraft.util.RandomSource;
 import net.minecraft.util.TimeSource;
 import net.minecraft.util.datafix.DataFixers;
@@ -165,7 +167,49 @@ public class Util {
         if (i <= 0) {
             executorService = MoreExecutors.newDirectExecutorService();
         } else {
-            executorService = new java.util.concurrent.ThreadPoolExecutor(i, i,0L, TimeUnit.MILLISECONDS, new java.util.concurrent.LinkedBlockingQueue<Runnable>(), target -> new io.papermc.paper.util.ServerWorkerThread(target, s, priorityModifier));
+            // Prismarine start - JettPack tweaks
+            if (net.prismarineteam.prismarine.PrismarineConfig.useJettPackAsyncExecutor) {
+                executorService = Integer.getInteger("Paper.WorkerThreadCount", i) <= 0 ? MoreExecutors.newDirectExecutorService() : new java.util.concurrent.AbstractExecutorService() {
+                    private volatile boolean shutdown = false;
+
+                    @Override
+                    public final List<Runnable> shutdownNow() {
+                        this.shutdown = true;
+                        return java.util.Collections.emptyList();
+                    }
+
+                    @Override
+                    public final void shutdown() {
+                        this.shutdown = true;
+                    }
+
+                    @Override
+                    public final boolean isShutdown() {
+                        return this.shutdown;
+                    }
+
+                    @Override
+                    public final boolean isTerminated() {
+                        return this.shutdown;
+                    }
+
+                    @Override
+                    public final boolean awaitTermination(long l2, TimeUnit timeUnit) throws InterruptedException {
+                        if (!this.shutdown) {
+                            throw new UnsupportedOperationException();
+                        }
+                        return true;
+                    }
+
+                    @Override
+                    public final void execute(Runnable runnable) {
+                        MCUtil.asyncExecutor.execute(new ServerWorkerWrapper(runnable));
+                    }
+                };
+            } else {
+                executorService = new java.util.concurrent.ThreadPoolExecutor(i, i,0L, TimeUnit.MILLISECONDS, new java.util.concurrent.LinkedBlockingQueue<Runnable>(), target -> new io.papermc.paper.util.ServerWorkerThread(target, s, priorityModifier));
+            }
+            // Prismarine end
         }
         /*
                     @Override
diff --git a/src/main/java/net/minecraft/core/Direction.java b/src/main/java/net/minecraft/core/Direction.java
index 6c27b22dd1d497687c0f4d3835e34149bcf952c1..384ae82ca4b535e7af4ad88c498f8090f5cce322 100644
--- a/src/main/java/net/minecraft/core/Direction.java
+++ b/src/main/java/net/minecraft/core/Direction.java
@@ -41,7 +41,7 @@ public enum Direction implements StringRepresentable {
     private final Direction.Axis axis;
     private final Direction.AxisDirection axisDirection;
     private final Vec3i normal;
-    private static final Direction[] VALUES = values();
+    public static final Direction[] VALUES = values(); // JettPack - private -> public // Prismarine - JettPack patches
     private static final Direction[] BY_3D_DATA = Arrays.stream(VALUES).sorted(Comparator.comparingInt((direction) -> {
         return direction.data3d;
     })).toArray((i) -> {
@@ -196,7 +196,7 @@ public enum Direction implements StringRepresentable {
     }
 
     public Direction getOpposite() {
-        return from3DDataValue(this.oppositeIndex);
+        return VALUES[this.oppositeIndex]; // JettPack - lithium: fast_util
     }
 
     public Direction getClockWise(Direction.Axis axis) {
@@ -458,7 +458,7 @@ public enum Direction implements StringRepresentable {
     }
 
     public static Direction getRandom(RandomSource random) {
-        return Util.getRandom(VALUES, random);
+        return VALUES[random.nextInt(VALUES.length)]; // JettPack - lithium: fast_util
     }
 
     public static Direction getNearest(double x, double y, double z) {
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 1a8dffe6b975e1ac3b4db98bf8a6b36b687e4ae0..02c130383c0d26626ae867d1ceaba13517970cf8 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1004,6 +1004,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         LOGGER.info("Flushing Chunk IO");
         io.papermc.paper.chunk.system.io.RegionFileIOThread.close(true); // Paper // Paper - rewrite chunk system
         LOGGER.info("Closing Thread Pool");
+        io.papermc.paper.util.MCUtil.flushAsyncTasks(); // Prismarine - JettPack patches
         Util.shutdownExecutors(); // Paper
         LOGGER.info("Closing Server");
         try {
@@ -1469,6 +1470,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         io.papermc.paper.util.CachedLists.reset(); // Paper
         // Paper start - move executeAll() into full server tick timing
         //try (co.aikar.timings.Timing ignored = MinecraftTimings.processTasksTimer.startTiming()) { // Purpur
+        io.papermc.paper.util.MCUtil.flushAsyncTasks(); // Prismarine - JettPack patches
             this.runAllTasks();
         //} // Purpur
         // Paper end
@@ -2766,6 +2768,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             return;
         }
 
+        io.papermc.paper.util.MCUtil.flushAsyncTasks(); // Prismarine - JettPack patches
         //co.aikar.timings.MinecraftTimings.midTickChunkTasks.startTiming(); // Purpur
         try {
             for (;;) {
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServerProperties.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServerProperties.java
index 01ca7156d86243a80cd343a2a66be9ebedcc3b7c..88900f7a2077049cc5d78fe17314dbdf57d64a08 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServerProperties.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServerProperties.java
@@ -137,7 +137,7 @@ public class DedicatedServerProperties extends Settings<DedicatedServerPropertie
         this.maxWorldSize = this.get("max-world-size", (integer) -> {
             return Mth.clamp(integer, (int) 1, 29999984);
         }, 29999984);
-        this.syncChunkWrites = this.get("sync-chunk-writes", true) && Boolean.getBoolean("Paper.enable-sync-chunk-writes"); // Paper - hide behind flag
+        this.syncChunkWrites = this.get("sync-chunk-writes", true) || Boolean.getBoolean("Paper.enable-sync-chunk-writes"); // Paper - hide behind flag // Prismarine - JettPack patches
         this.enableJmxMonitoring = this.get("enable-jmx-monitoring", false);
         this.enableStatus = this.get("enable-status", true);
         this.hideOnlinePlayers = this.get("hide-online-players", false);
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 1a758d44459736fc5934b4ee3ebd98063ea1d04f..1e9d78801c32b21dc26e83ed710ad21e86b76f30 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -940,7 +940,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
                     continue;
                 }
 
-                int yPos = (sectionIndex + minSection) << 4;
+                int yPos = ((sectionIndex + minSection) << 4) + 4096; // Prismarine - JettPack patches (0058)
                 for (int a = 0; a < randomTickSpeed; ++a) {
                     int tickingBlocks = section.tickingList.size();
                     int index = this.randomTickRandom.nextInt(16 * 16 * 16);
@@ -951,13 +951,13 @@ public class ServerLevel extends Level implements WorldGenLevel {
                     long raw = section.tickingList.getRaw(index);
                     int location = com.destroystokyo.paper.util.maplist.IBlockDataList.getLocationFromRaw(raw);
                     int randomX = location & 15;
-                    int randomY = ((location >>> (4 + 4)) & 255) | yPos;
+                    int randomY = (((location >>> 8) & 4095) | yPos) - 4096; // Prismarine - JettPack patches (0058)
                     int randomZ = (location >>> 4) & 15;
 
                     BlockPos blockposition2 = blockposition.set(j + randomX, randomY, k + randomZ);
                     BlockState iblockdata = com.destroystokyo.paper.util.maplist.IBlockDataList.getBlockDataFromRaw(raw);
 
-                    iblockdata.randomTick(this, blockposition2, this.randomTickRandom);
+                    iblockdata.randomTick(this, blockposition2.immutable(), this.randomTickRandom); // Prismarine - reduce allocs
                     // We drop the fluid tick since LAVA is ALREADY TICKED by the above method (See LiquidBlock).
                     // TODO CHECK ON UPDATE
                 }
diff --git a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
index 3a62b456e1f8ab68e3c34b9d73b822e379afd570..38ac9aebd3f0687c57d9ed8186cb90e489655d47 100644
--- a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
@@ -131,6 +131,13 @@ public class ServerLoginPacketListenerImpl implements TickablePacketListener, Se
 
     private static final java.util.concurrent.ExecutorService authenticatorPool = new java.util.concurrent.ThreadPoolExecutor(0, 16, 60L, java.util.concurrent.TimeUnit.SECONDS, new java.util.concurrent.LinkedBlockingQueue<>(),  new com.google.common.util.concurrent.ThreadFactoryBuilder().setNameFormat("User Authenticator #%d").setUncaughtExceptionHandler(new DefaultUncaughtExceptionHandler(LOGGER)).build()); // Paper - Cache authenticator threads
 
+    // Prismarine start
+    private java.util.concurrent.ExecutorService getAuthenticatorPool() {
+        if (net.prismarineteam.prismarine.PrismarineConfig.useAsyncExecutorAtAuthencatorPool) return io.papermc.paper.util.MCUtil.asyncExecutor;
+        else return authenticatorPool;
+    }
+    // Prismarine end
+
     // Spigot start
     public void initUUID()
     {
@@ -304,7 +311,7 @@ public class ServerLoginPacketListenerImpl implements TickablePacketListener, Se
                 // Paper end
                 // Spigot start
             // Paper start - Cache authenticator threads
-            authenticatorPool.execute(new Runnable() {
+            getAuthenticatorPool().execute(new Runnable() {
                     @Override
                     public void run() {
                         try {
@@ -362,7 +369,7 @@ public class ServerLoginPacketListenerImpl implements TickablePacketListener, Se
         }
 
         // Paper start - Cache authenticator threads
-        authenticatorPool.execute(new Runnable() {
+        getAuthenticatorPool().execute(new Runnable() {
             public void run() {
                 GameProfile gameprofile = ServerLoginPacketListenerImpl.this.gameProfile;
 
@@ -512,7 +519,7 @@ public class ServerLoginPacketListenerImpl implements TickablePacketListener, Se
             }
 
             // Proceed with login
-            authenticatorPool.execute(() -> {
+            getAuthenticatorPool().execute(() -> {
                 try {
                     new LoginHandler().fireEvents();
                 } catch (Exception ex) {
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 82634bd0ab2792f637573c2ee7d9d00ba1104900..89310e0759d4a3d215112f83630ed193596fd2ce 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -505,7 +505,13 @@ public abstract class PlayerList {
         // Paper end
         org.purpurmc.purpur.task.BossBarTask.addToAll(player); // Purpur
         // CraftBukkit - Moved from above, added world
-        PlayerList.LOGGER.info("{}[{}] logged in with entity id {} at ([{}]{}, {}, {})", player.getName().getString(), s1, player.getId(), worldserver1.serverLevelData.getLevelName(), player.getX(), player.getY(), player.getZ());
+        // Prismarine start - JettPack patches (configurable logging of player login location)
+        if (net.prismarineteam.prismarine.PrismarineConfig.logPlayerLoginLocation) {
+            PlayerList.LOGGER.info("{}[{}] logged in with entity id {} at ([{}]{}, {}, {})", player.getName().getString(), s1, player.getId(), worldserver1.serverLevelData.getLevelName(), player.getX(), player.getY(), player.getZ());
+        } else {
+            PlayerList.LOGGER.info("{}[{}] logged in with entity id {}", player.getName().getString(), s1, player.getId());
+        }
+        // Prismarine end
     }
 
     public void updateEntireScoreboard(ServerScoreboard scoreboard, ServerPlayer player) {
diff --git a/src/main/java/net/minecraft/util/BitStorage.java b/src/main/java/net/minecraft/util/BitStorage.java
index 106610ccc74b70b557b01c61262d56c4f1147acf..290fdadb522bc201d8f4453fe4333a98f387ec15 100644
--- a/src/main/java/net/minecraft/util/BitStorage.java
+++ b/src/main/java/net/minecraft/util/BitStorage.java
@@ -31,4 +31,6 @@ public interface BitStorage {
 
     }
     // Paper end
+
+    <T> void compact(net.minecraft.world.level.chunk.Palette<T> srcPalette, net.minecraft.world.level.chunk.Palette<T> dstPalette, short[] out); // Prismarine - JettPack patches (0044 - lithium: chunk.serialization)
 }
diff --git a/src/main/java/net/minecraft/util/ClassInstanceMultiMap.java b/src/main/java/net/minecraft/util/ClassInstanceMultiMap.java
index 50a9f33aa31e9273c7c52d4bb2b02f0f884f7ba5..76bb6cc0d28227afd6c0a62c1a13537d8a8c1907 100644
--- a/src/main/java/net/minecraft/util/ClassInstanceMultiMap.java
+++ b/src/main/java/net/minecraft/util/ClassInstanceMultiMap.java
@@ -13,7 +13,7 @@ import java.util.Map;
 import java.util.stream.Collectors;
 
 public class ClassInstanceMultiMap<T> extends AbstractCollection<T> {
-    private final Map<Class<?>, List<T>> byClass = Maps.newHashMap();
+    private final Map<Class<?>, List<T>> byClass = net.prismarineteam.prismarine.PrismarineConfig.useLithiumEntityByType ? new it.unimi.dsi.fastutil.objects.Reference2ReferenceOpenHashMap<>() : Maps.newHashMap(); // Prismarine - JettPack patches (lithium: collections.entity_by_type)
     private final Class<T> baseClass;
     private final List<T> allInstances = Lists.newArrayList();
 
@@ -54,11 +54,32 @@ public class ClassInstanceMultiMap<T> extends AbstractCollection<T> {
         return this.find(object.getClass()).contains(object);
     }
 
+    // Prismarine start - JettPack patches
+    private <S> Collection<T> createAllOfType(Class<S> type) {
+        List<T> list = new java.util.ArrayList<>();
+
+        for (T allElement : this.allInstances) {
+            if (type.isInstance(allElement)) {
+                list.add(allElement);
+            }
+        }
+
+        this.byClass.put(type, list);
+
+        return list;
+    }
+
     public <S> Collection<S> find(Class<S> type) {
+        if (net.prismarineteam.prismarine.PrismarineConfig.useLithiumEntityFiltering) {
+            Collection<T> collection = this.byClass.get(type);
+            if (collection == null) collection = this.createAllOfType(type);
+            return (Collection<S>) Collections.unmodifiableCollection(collection);
+        } else
+    // Prismarine end
         if (!this.baseClass.isAssignableFrom(type)) {
             throw new IllegalArgumentException("Don't know how to search for " + type);
         } else {
-            List<? extends T> list = this.byClass.computeIfAbsent(type, (typeClass) -> {
+            List list = this.byClass.computeIfAbsent(type, (typeClass) -> { // Prismarine - decomp fix
                 return this.allInstances.stream().filter(typeClass::isInstance).collect(Collectors.toList());
             });
             return Collections.unmodifiableCollection(list);
diff --git a/src/main/java/net/minecraft/util/Mth.java b/src/main/java/net/minecraft/util/Mth.java
index 46e3e884890a23f5f90efc795a21566dd40804df..ef48024a21401c8c3543628e5da35f21d8d52a61 100644
--- a/src/main/java/net/minecraft/util/Mth.java
+++ b/src/main/java/net/minecraft/util/Mth.java
@@ -25,7 +25,7 @@ public class Mth {
     public static final float EPSILON = 1.0E-5F;
     public static final float SQRT_OF_TWO = sqrt(2.0F);
     private static final float SIN_SCALE = 10430.378F;
-    private static final float[] SIN = Util.make(new float[65536], (sineTable) -> {
+    public static final float[] SIN = Util.make(new float[65536], (sineTable) -> { // Prismarine - private -> public (Jettpack Patches)
         for(int i = 0; i < sineTable.length; ++i) {
             sineTable[i] = (float)Math.sin((double)i * Math.PI * 2.0D / 65536.0D);
         }
@@ -41,10 +41,12 @@ public class Mth {
     private static final double[] COS_TAB = new double[257];
 
     public static float sin(float value) {
+        if (net.prismarineteam.prismarine.PrismarineConfig.useLithiumSine) return me.jellysquid.mods.lithium.common.util.math.CompactSineLUT.sin(value); // Prismarine - JettPack patches (lithium: math.sine_lut)
         return SIN[(int)(value * 10430.378F) & '\uffff'];
     }
 
     public static float cos(float value) {
+        if (net.prismarineteam.prismarine.PrismarineConfig.useLithiumCosine) return me.jellysquid.mods.lithium.common.util.math.CompactSineLUT.cos(value); // Prismarine - JettPack patches (lithium: math.sine_lut)
         return SIN[(int)(value * 10430.378F + 16384.0F) & '\uffff'];
     }
 
diff --git a/src/main/java/net/minecraft/util/SimpleBitStorage.java b/src/main/java/net/minecraft/util/SimpleBitStorage.java
index 36e33923bf48e56c743ed043bcbc66bc32f0422f..8986a34ae144103aa87b7f678f4c0c3871c47523 100644
--- a/src/main/java/net/minecraft/util/SimpleBitStorage.java
+++ b/src/main/java/net/minecraft/util/SimpleBitStorage.java
@@ -201,4 +201,44 @@ public class SimpleBitStorage implements BitStorage {
             super(message);
         }
     }
+
+    // Prismarine start - JettPack patches (0044 - lithium: chunk.serialization)
+    @Override
+    public <T> void compact(net.minecraft.world.level.chunk.Palette<T> srcPalette, net.minecraft.world.level.chunk.Palette<T> dstPalette, short[] out) {
+        if (this.size >= Short.MAX_VALUE) {
+            throw new IllegalStateException("Array too large");
+        }
+
+        if (this.size != out.length) {
+            throw new IllegalStateException("Array size mismatch");
+        }
+
+        short[] mappings = new short[(int) (this.mask + 1)];
+
+        int idx = 0;
+
+        for (long word : this.data) {
+            long bits = word;
+
+            for (int elementIdx = 0; elementIdx < this.valuesPerLong; ++elementIdx) {
+                int value = (int) (bits & this.mask);
+                int remappedId = mappings[value];
+
+                if (remappedId == 0) {
+                    remappedId = dstPalette.idFor(srcPalette.valueFor(value)) + 1;
+                    mappings[value] = (short) remappedId;
+                }
+
+                out[idx] = (short) (remappedId - 1);
+                bits >>= this.bits;
+
+                ++idx;
+
+                if (idx >= this.size) {
+                    return;
+                }
+            }
+        }
+    }
+    // Prismarine end
 }
diff --git a/src/main/java/net/minecraft/util/ZeroBitStorage.java b/src/main/java/net/minecraft/util/ZeroBitStorage.java
index 5d8e9bdf5538b19681f21949368d862fab8a89ad..347f1dd2fe964fe7f9c4ad9aa92b27c5b455b66b 100644
--- a/src/main/java/net/minecraft/util/ZeroBitStorage.java
+++ b/src/main/java/net/minecraft/util/ZeroBitStorage.java
@@ -72,4 +72,6 @@ public class ZeroBitStorage implements BitStorage {
     public BitStorage copy() {
         return this;
     }
+
+    @Override public <T> void compact(net.minecraft.world.level.chunk.Palette<T> srcPalette, net.minecraft.world.level.chunk.Palette<T> dstPalette, short[] out) {} // Prismarine - JettPack patches (0044 - lithium: chunk.serialization)
 }
diff --git a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
index 7a4ade1a4190bf4fbb048919ae2be230f7b80fff..ab33194cb4d00e033632e753fb131d553dc29d9a 100644
--- a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
+++ b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
@@ -8,6 +8,8 @@ import java.util.Queue;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import java.util.concurrent.locks.LockSupport;
+import java.util.concurrent.LinkedBlockingQueue; // JettPack // Prismarine - JettPack patches
+import java.util.concurrent.TimeUnit; // JettPack // Prismarine - JettPack patches
 import java.util.function.BooleanSupplier;
 import java.util.function.Supplier;
 import net.minecraft.util.profiling.metrics.MetricCategory;
@@ -19,8 +21,9 @@ import org.slf4j.Logger;
 public abstract class BlockableEventLoop<R extends Runnable> implements ProfilerMeasured, ProcessorHandle<R>, Executor {
     private final String name;
     private static final Logger LOGGER = LogUtils.getLogger();
-    private final Queue<R> pendingRunnables = Queues.newConcurrentLinkedQueue();
+    private final LinkedBlockingQueue<R> pendingRunnables = new LinkedBlockingQueue(); // JettPack // Prismarine - JettPack patches
     private int blockingCount;
+    private R next; // JettPack // Prismarine - JettPack patches
 
     protected BlockableEventLoop(String name) {
         this.name = name;
@@ -89,7 +92,7 @@ public abstract class BlockableEventLoop<R extends Runnable> implements Profiler
     @Override
     public void tell(R runnable) {
         this.pendingRunnables.add(runnable);
-        LockSupport.unpark(this.getRunningThread());
+        // LockSupport.unpark(this.getRunningThread()); // JettPack // Prismarine - JettPack patches
     }
 
     @Override
@@ -117,13 +120,20 @@ public abstract class BlockableEventLoop<R extends Runnable> implements Profiler
     }
 
     public boolean pollTask() {
-        R runnable = this.pendingRunnables.peek();
-        if (runnable == null) {
-            return false;
-        } else if (this.blockingCount == 0 && !this.shouldRun(runnable)) {
+        // Prismarine start - JettPack patches
+        if (this.next == null && !this.pendingRunnables.isEmpty()) {
+            this.waitForTasks();
+        }
+
+        if (this.next == null) {
+        // Prismarine end
             return false;
         } else {
-            this.doRunTask(this.pendingRunnables.remove());
+            // Prismarine start - JettPack patches
+            R r2 = this.next;
+            this.next = null;
+            this.doRunTask(r2);
+            // Prismarine end
             return true;
         }
     }
@@ -144,8 +154,18 @@ public abstract class BlockableEventLoop<R extends Runnable> implements Profiler
     }
 
     protected void waitForTasks() {
-        Thread.yield();
-        LockSupport.parkNanos("waiting for tasks", 100000L);
+        // Jettpack start
+        if (this.next != null) {
+            throw new IllegalStateException("next != null");
+        }
+        try {
+            this.next = this.pendingRunnables.poll(100L, TimeUnit.MICROSECONDS);
+            return;
+        }
+        catch (InterruptedException interruptedException) {
+            return;
+        }
+        // Jettpack end
     }
 
     protected void doRunTask(R task) {
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index 2163a1ac3a9e3c39bdef7ea57b19caa213dbb16c..aa7afa4b399d92e0114860674d360106dd109525 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -576,11 +576,11 @@ public abstract class LivingEntity extends Entity {
     }
 
     protected void tryAddFrost() {
-        if (!this.getBlockStateOnLegacy().isAir()) {
+        //if (!this.getBlockStateOnLegacy().isAir()) { // Prismarine - JettPack patches (lithium: entity.fast_powder_snow_check)
             int i = this.getTicksFrozen();
 
             if (i > 0) {
-                AttributeInstance attributemodifiable = this.getAttribute(Attributes.MOVEMENT_SPEED);
+                AttributeInstance attributemodifiable = this.getBlockStateOn().isAir() ? null : this.getAttribute(Attributes.MOVEMENT_SPEED); // Prismarine - JettPack patches (lithium: entity.fast_powder_snow_check)
 
                 if (attributemodifiable == null) {
                     return;
@@ -590,7 +590,7 @@ public abstract class LivingEntity extends Entity {
 
                 attributemodifiable.addTransientModifier(new AttributeModifier(LivingEntity.SPEED_MODIFIER_POWDER_SNOW_UUID, "Powder snow slow", (double) f, AttributeModifier.Operation.ADDITION));
             }
-        }
+        //} // Prismarine - JettPack patches (lithium: entity.fast_powder_snow_check)
 
     }
 
@@ -2551,6 +2551,7 @@ public abstract class LivingEntity extends Entity {
     }
 
     protected void updateSwingTime() {
+        if (!this.swinging && this.swingTime == 0) return; // JettPack - lithium: entity.fast_hand_swing
         int i = this.getCurrentSwingDuration();
 
         if (this.swinging) {
diff --git a/src/main/java/net/minecraft/world/entity/Mob.java b/src/main/java/net/minecraft/world/entity/Mob.java
index 7809f341dc76536250b4eb3809de9368b5c2d652..c6b43a4f148b39132cfc7139610d900327d069e6 100644
--- a/src/main/java/net/minecraft/world/entity/Mob.java
+++ b/src/main/java/net/minecraft/world/entity/Mob.java
@@ -841,7 +841,7 @@ public abstract class Mob extends LivingEntity {
         } else if (!this.isPersistenceRequired() && !this.requiresCustomPersistence()) {
             // Paper start - optimise checkDespawn
             Player entityhuman = this.level.findNearbyPlayer(this, level.paperConfig().entities.spawning.despawnRanges.get(this.getType().getCategory()).hard() + 1, EntitySelector.PLAYER_AFFECTS_SPAWNING); // Paper
-            if (entityhuman == null) {
+            if (entityhuman == null || this.level.prismarineConfig.despawnMobWhenNoPlayerIsOnRange) { // Prismarine) {
                 entityhuman = ((ServerLevel)this.level).playersAffectingSpawning.isEmpty() ? null : ((ServerLevel)this.level).playersAffectingSpawning.get(0);
             }
             // Paper end - optimise checkDespawn
@@ -863,6 +863,7 @@ public abstract class Mob extends LivingEntity {
                 } else if (d0 < (double) l) {
                     this.noActionTime = 0;
                 }
+            } else if (this.level.prismarineConfig.despawnMobWhenNoPlayerIsOnRange) { this.discard(); // Prismarine
             }
 
         } else {
diff --git a/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
index 2c915c765ceef3ec28f5a58fa9a587282c1a906a..2840b720b6fb8d74710845d9186e565f3f99b10b 100644
--- a/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
+++ b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
@@ -19,8 +19,8 @@ import org.slf4j.Logger;
 
 public class AttributeMap {
     private static final Logger LOGGER = LogUtils.getLogger();
-    private final Map<Attribute, AttributeInstance> attributes = Maps.newHashMap();
-    private final Set<AttributeInstance> dirtyAttributes = Sets.newHashSet();
+    private final Map<Attribute, AttributeInstance> attributes = net.prismarineteam.prismarine.PrismarineConfig.useLithiumAttributes ? new it.unimi.dsi.fastutil.objects.Reference2ReferenceOpenHashMap<>() : Maps.newHashMap(); // Prismarine - JettPack patches (lithium: collections.attributes)
+    private final Set<AttributeInstance> dirtyAttributes = net.prismarineteam.prismarine.PrismarineConfig.useLithiumAttributes ? new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<>() : Sets.newHashSet(); // Prismarine - JettPack patches (lithium: collections.attributes)
     private final AttributeSupplier supplier;
     private final net.minecraft.world.entity.LivingEntity entity; // Purpur
     private final java.util.function.Function<Attribute, AttributeInstance> createInstance; // Pufferfish
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java b/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
index 872ec431ae6beb0ef603d833f38aedb9d87e5466..59014e55a6848addfd67cfc2bc0366e313c0145d 100644
--- a/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
@@ -27,7 +27,7 @@ public class GoalSelector {
         }
     };
     private final Map<Goal.Flag, WrappedGoal> lockedFlags = new EnumMap<>(Goal.Flag.class);
-    public final Set<WrappedGoal> availableGoals = Sets.newLinkedHashSet();
+    public final Set<WrappedGoal> availableGoals = new it.unimi.dsi.fastutil.objects.ObjectLinkedOpenHashSet<>(); // JettPack - lithium: replace AI goal set with optimized collection // Prismarine - JettPack patches
     private final Supplier<ProfilerFiller> profiler;
     private final EnumSet<Goal.Flag> disabledFlags = EnumSet.noneOf(Goal.Flag.class); // Paper unused, but dummy to prevent plugins from crashing as hard. Theyll need to support paper in a special case if this is super important, but really doesn't seem like it would be.
     private final com.destroystokyo.paper.util.set.OptimizedSmallEnumSet<net.minecraft.world.entity.ai.goal.Goal.Flag> goalTypes = new com.destroystokyo.paper.util.set.OptimizedSmallEnumSet<>(Goal.Flag.class); // Paper - remove streams from pathfindergoalselector
diff --git a/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java b/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
index f5886a88fd98ede5e85a91eccccb05ac33eb40e2..b4403229fb9ff45410b63d2d1459f9cb5c56cd5e 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
@@ -264,7 +264,7 @@ public class FishingHook extends Projectile {
         boolean flag = itemstack.is(Items.FISHING_ROD);
         boolean flag1 = itemstack1.is(Items.FISHING_ROD);
 
-        if (!player.isRemoved() && player.isAlive() && (flag || flag1) && this.distanceToSqr((Entity) player) <= 1024.0D) {
+        if (!player.isRemoved() && player.isAlive() && (flag || flag1) && this.distanceToSqr((Entity) player) <= player.getLevel().prismarineConfig.fishingRodLength) { // Prismarine - JettPack patches
             return false;
         } else {
             this.discard();
diff --git a/src/main/java/net/minecraft/world/item/crafting/Ingredient.java b/src/main/java/net/minecraft/world/item/crafting/Ingredient.java
index 809c6531d056cc9538e9bec9cdc5ca6e4c9f4792..ff7b3babb557d21f83f75c34bf47b8aa8bf91d6d 100644
--- a/src/main/java/net/minecraft/world/item/crafting/Ingredient.java
+++ b/src/main/java/net/minecraft/world/item/crafting/Ingredient.java
@@ -38,6 +38,8 @@ public final class Ingredient implements Predicate<ItemStack> {
     @Nullable
     private IntList stackingIds;
     public boolean exact; // CraftBukkit
+    private java.util.Set<Item> matchingItems = null; // Prismarine - JettPack patches (VMP: ingredient matching cache)
+    private boolean isEmptyMatch = false; // Prismarine - JettPack patches (VMP: ingredient matching cache)
     public Predicate<org.bukkit.inventory.ItemStack> predicate;
 
     public Ingredient(Stream<? extends Ingredient.Value> entries) {
@@ -70,6 +72,22 @@ public final class Ingredient implements Predicate<ItemStack> {
         if (itemstack == null) {
             return false;
         } else {
+            if (net.prismarineteam.prismarine.PrismarineConfig.useExperimentalVMPIngredientMatchingCache) {
+                java.util.Set<Item> matchingItems = this.matchingItems;
+                boolean isEmptyMatch = this.isEmptyMatch;
+                if (matchingItems == null) {
+                    matchingItems = this.matchingItems = Arrays.stream(this.values)
+                            .flatMap(entry -> entry.getItems().stream())
+                            .filter(itemstack1 -> !itemstack1.isEmpty())
+                            .map(ItemStack::getItem)
+                            .collect(java.util.stream.Collectors.toCollection(java.util.HashSet::new));
+                    isEmptyMatch = this.isEmptyMatch = this.matchingItems.isEmpty();
+                }
+                if (itemstack.isEmpty()) {
+                    return isEmptyMatch;
+                }
+                return matchingItems.contains(itemstack.getItem());
+            } else {// Prismarine - JettPack patches (VMP: ingredient matching cache)
             this.dissolve();
             if (this.itemStacks.length == 0) {
                 return itemstack.isEmpty();
@@ -102,6 +120,7 @@ public final class Ingredient implements Predicate<ItemStack> {
 
                 return false;
             }
+            }// Prismarine - JettPack patches (VMP: ingredient matching cache)
         }
     }
 
diff --git a/src/main/java/net/minecraft/world/level/EntityBasedExplosionDamageCalculator.java b/src/main/java/net/minecraft/world/level/EntityBasedExplosionDamageCalculator.java
index 2f9f15d99f8b31e9f13f7f32378b2a9e09bcb5e5..47b5f310c8db91940a454a92058f44c457f69f1e 100644
--- a/src/main/java/net/minecraft/world/level/EntityBasedExplosionDamageCalculator.java
+++ b/src/main/java/net/minecraft/world/level/EntityBasedExplosionDamageCalculator.java
@@ -15,9 +15,17 @@ public class EntityBasedExplosionDamageCalculator extends ExplosionDamageCalcula
 
     @Override
     public Optional<Float> getBlockExplosionResistance(Explosion explosion, BlockGetter world, BlockPos pos, BlockState blockState, FluidState fluidState) {
-        return super.getBlockExplosionResistance(explosion, world, pos, blockState, fluidState).map((max) -> {
-            return this.source.getBlockExplosionResistance(explosion, world, pos, blockState, fluidState, max);
-        });
+        // Prismarine start - JettPack patches (lithium: reduce allocs)
+        Optional<Float> optionalBlastResistance = super.getBlockExplosionResistance(explosion, world, pos, blockState, fluidState);
+        if (optionalBlastResistance.isPresent()) {
+            float blastResistance = optionalBlastResistance.get();
+            float effectiveExplosionResistance = this.source.getBlockExplosionResistance(explosion, world, pos, blockState, fluidState, blastResistance);
+            if (effectiveExplosionResistance != blastResistance) {
+                return Optional.of(effectiveExplosionResistance);
+            }
+        }
+        return optionalBlastResistance;
+        // Prismarine end
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index aa47d6e12c2472a58ba102a618d704e39a0777df..24f55068da24f0685aa48e2cef48802055c8f2b6 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -117,9 +117,9 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public static final int TICKS_PER_DAY = 24000;
     public static final int MAX_ENTITY_SPAWN_Y = 20000000;
     public static final int MIN_ENTITY_SPAWN_Y = -20000000;
-    protected final List<TickingBlockEntity> blockEntityTickers = Lists.newArrayList(); public final int getTotalTileEntityTickers() { return this.blockEntityTickers.size(); } // Paper
+    protected final List<TickingBlockEntity> blockEntityTickers = me.jellysquid.mods.lithium.common.util.collections.HashedList.wrapper(Lists.newArrayList()); public final int getTotalTileEntityTickers() { return this.blockEntityTickers.size(); } // Paper // Jettpack - lithium: hashed_list // Prismarine - JettPack patches
     protected final NeighborUpdater neighborUpdater;
-    private final List<TickingBlockEntity> pendingBlockEntityTickers = Lists.newArrayList();
+    private final List<TickingBlockEntity> pendingBlockEntityTickers = me.jellysquid.mods.lithium.common.util.collections.HashedList.wrapper(Lists.newArrayList()); // Jettpack - lithium: hashed_list // Prismarine - JettPack patches
     private boolean tickingBlockEntities;
     public final Thread thread;
     private final boolean isDebug;
diff --git a/src/main/java/net/minecraft/world/level/block/Block.java b/src/main/java/net/minecraft/world/level/block/Block.java
index e94ca6283a0471a49b31942de763472ccb989dcb..75e44de348a33991761f1306d0ebcfee5e96e22f 100644
--- a/src/main/java/net/minecraft/world/level/block/Block.java
+++ b/src/main/java/net/minecraft/world/level/block/Block.java
@@ -673,11 +673,13 @@ public class Block extends BlockBehaviour implements ItemLike {
         private final BlockState first;
         private final BlockState second;
         private final Direction direction;
+        private int hash; // Prismarine - JettPack patches (lithium: cached_hashcode)
 
         public BlockStatePairKey(BlockState self, BlockState other, Direction facing) {
             this.first = self;
             this.second = other;
             this.direction = facing;
+            this.hash = 31 * (31 * this.first.hashCode() + this.second.hashCode()) + this.direction.hashCode(); // Prismarine - JettPack patches (lithium: cached_hashcode)
         }
 
         public boolean equals(Object object) {
@@ -693,11 +695,7 @@ public class Block extends BlockBehaviour implements ItemLike {
         }
 
         public int hashCode() {
-            int i = this.first.hashCode();
-
-            i = 31 * i + this.second.hashCode();
-            i = 31 * i + this.direction.hashCode();
-            return i;
+            return this.hash; // Prismarine - JettPack patches (lithium: cached_hashcode)
         }
     }
 }
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
index f25467ad1c5bac7eaef4b63b2845ad04d7c76e4e..5019bac4a8f63181d22c43a676c12d24e060a184 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
@@ -192,7 +192,7 @@ public class LevelChunkSection {
             if (iblockdata1.isRandomlyTicking()) {
                 --this.tickingBlockCount;
                 // Paper start
-                this.tickingList.remove(x, y, z);
+                this.tickingList.remove(x, y + 4096, z); // Prismarine - JettPack patches (0058)
                 // Paper end
             }
         }
@@ -207,7 +207,7 @@ public class LevelChunkSection {
             if (state.isRandomlyTicking()) {
                 ++this.tickingBlockCount;
                 // Paper start
-                this.tickingList.add(x, y, z, state);
+                this.tickingList.add(x, y + 4096, z, state); // Prismarine - JettPack patches (0058)
                 // Paper end
             }
         }
diff --git a/src/main/java/net/minecraft/world/level/chunk/PaletteResize.java b/src/main/java/net/minecraft/world/level/chunk/PaletteResize.java
index acae3eb30e0689048937f479dc3070f0688abdad..a6a0a39f9d25960d78aae9856b805bcd1b74787b 100644
--- a/src/main/java/net/minecraft/world/level/chunk/PaletteResize.java
+++ b/src/main/java/net/minecraft/world/level/chunk/PaletteResize.java
@@ -1,5 +1,5 @@
 package net.minecraft.world.level.chunk;
 
-interface PaletteResize<T> {
+public interface PaletteResize<T> { // Prismarine - package -> public
     int onResize(int newBits, T object);
 }
diff --git a/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java b/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
index 7908360dd47937b2cb702e381802b7b278a5198e..ab816eac615a37fb58e36d213a3d94795e8fbb60 100644
--- a/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
+++ b/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
@@ -24,6 +24,18 @@ import net.minecraft.util.ThreadingDetector;
 import net.minecraft.util.ZeroBitStorage;
 
 public class PalettedContainer<T> implements PaletteResize<T>, PalettedContainerRO<T> {
+    // Prismarine start - JettPack patches (0044 - lithium: chunk.serialization)
+    private static final ThreadLocal<short[]> CACHED_ARRAY_4096 = ThreadLocal.withInitial(() -> new short[4096]);
+    private static final ThreadLocal<short[]> CACHED_ARRAY_64 = ThreadLocal.withInitial(() -> new short[64]);
+    private Optional<LongStream> asOptional(long[] data) { return Optional.of(Arrays.stream(data)); }
+    private short[] getOrCreate(int size) {
+        return switch (size) {
+            case 4096 -> CACHED_ARRAY_4096.get();
+            case 64 -> CACHED_ARRAY_64.get();
+            default -> new short[size];
+        };
+    }
+    // Prismarine end
     private static final int MIN_PALETTE_BITS = 0;
     private final PaletteResize<T> dummyPaletteResize = (newSize, added) -> {
         return 0;
@@ -299,30 +311,53 @@ public class PalettedContainer<T> implements PaletteResize<T>, PalettedContainer
     public synchronized PalettedContainerRO.PackedData<T> pack(IdMap<T> idList, PalettedContainer.Strategy paletteProvider) { // Paper - synchronize
         this.acquire();
 
-        PalettedContainerRO.PackedData var12;
+        // Prismarine start - JettPack patches (0044 - lithium: chunk.serialization)
+        Optional<LongStream> data = Optional.empty();
+        List<T> elements = null;
         try {
-            HashMapPalette<T> hashMapPalette = new HashMapPalette<>(idList, this.data.storage.getBits(), this.dummyPaletteResize);
-            int i = paletteProvider.size();
-            int[] is = new int[i];
-            this.data.storage.unpack(is);
-            swapPalette(is, (id) -> {
-                return hashMapPalette.idFor(this.data.palette.valueFor(id));
-            });
-            int j = paletteProvider.calculateBitsForSerialization(idList, hashMapPalette.getSize());
-            Optional<LongStream> optional;
-            if (j != 0) {
-                SimpleBitStorage simpleBitStorage = new SimpleBitStorage(j, i, is);
-                optional = Optional.of(Arrays.stream(simpleBitStorage.getRaw()));
-            } else {
-                optional = Optional.empty();
+            // The palette that will be serialized
+            me.jellysquid.mods.lithium.common.world.chunk.LithiumHashPalette<T> hashPalette = null;
+            final Palette<T> palette = this.data.palette();
+            final BitStorage storage = this.data.storage();
+
+            if (storage instanceof ZeroBitStorage || palette.getSize() == 1) {
+                // If the palette only contains one entry, don't attempt to repack it.
+                elements = List.of(palette.valueFor(0));
+            } else if (palette instanceof me.jellysquid.mods.lithium.common.world.chunk.LithiumHashPalette<T> lithiumHashPalette) {
+                hashPalette = lithiumHashPalette;
             }
 
-            var12 = new PalettedContainerRO.PackedData<>(hashMapPalette.getEntries(), optional);
+            if (elements == null) {
+                me.jellysquid.mods.lithium.common.world.chunk.LithiumHashPalette compactedPalette = new me.jellysquid.mods.lithium.common.world.chunk.LithiumHashPalette<>(idList, storage.getBits(), this.dummyPaletteResize);
+                short[] array = this.getOrCreate(paletteProvider.size());
+
+                storage.compact(palette, compactedPalette, array);
+
+                // If the palette didn't change during compaction, do a simple copy of the data array
+                if (hashPalette != null && hashPalette.getSize() == compactedPalette.getSize() && storage.getBits() == paletteProvider.calculateBitsForSerialization(idList, hashPalette.getSize())) { // paletteSize can de-sync from palette - see https://github.com/CaffeineMC/lithium-fabric/issues/279
+                    data = this.asOptional(storage.getRaw().clone());
+                    elements = hashPalette.getElements();
+                } else {
+                    int bits = paletteProvider.calculateBitsForSerialization(idList, compactedPalette.getSize());
+                    if (bits != 0) {
+                        // Re-pack the int array as the palette has changed size
+                        SimpleBitStorage copy = new SimpleBitStorage(bits, array.length);
+                        for (int i = 0; i < array.length; ++i) {
+                            copy.set(i, array[i]);
+                        }
+
+                        // We don't need to clone the data array as we're the sole owner of it
+                        data = this.asOptional(copy.getRaw());
+                    }
+                    elements = compactedPalette.getElements();
+                }
+            }
         } finally {
             this.release();
         }
 
-        return var12;
+        return new PalettedContainerRO.PackedData<>(elements, data);
+        // Prismarine end
     }
 
     private static <T> void swapPalette(int[] is, IntUnaryOperator applier) {
@@ -362,6 +397,12 @@ public class PalettedContainer<T> implements PaletteResize<T>, PalettedContainer
 
     @Override
     public void count(PalettedContainer.CountConsumer<T> counter) {
+        // Prismarine start - JettPack patches (0044 - lithium: chunk.serialization)
+        int len = this.data.palette().getSize();
+
+        // Don't allocate huge arrays if we're using a large palette
+        if (len > 4096) {
+        // Vanilla start
         if (this.data.palette.getSize() == 1) {
             counter.accept(this.data.palette.valueFor(0), this.data.storage.getSize());
         } else {
@@ -373,6 +414,15 @@ public class PalettedContainer<T> implements PaletteResize<T>, PalettedContainer
                 counter.accept(this.data.palette.valueFor(entry.getIntKey()), entry.getIntValue());
             });
         }
+        // Vanilla end
+        }
+        short[] counts = new short[len];
+        this.data.storage().getAll(i -> counts[i]++);
+        for (int i = 0; i < counts.length; i++) {
+            T obj = this.data.palette().valueFor(i);
+            if (obj != null) counter.accept(obj, counts[i]);
+        }
+        // Prismarine end
     }
 
     static record Configuration<T>(Palette.Factory factory, int bits) {
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
index dfe2a2c13b149c20728112d4e9dfcfa8f118e541..02d877ebc0f4e0e8d24c1c432f8a654bef01f30f 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
@@ -113,7 +113,7 @@ public class RegionFileStorage implements AutoCloseable {
 
     // Paper start
     private static void printOversizedLog(String msg, Path file, int x, int z) {
-        org.apache.logging.log4j.LogManager.getLogger().fatal(msg + " (" + file.toString().replaceAll(".+[\\\\/]", "") + " - " + x + "," + z + ") Go clean it up to remove this message. /minecraft:tp " + (x<<4)+" 128 "+(z<<4) + " - DO NOT REPORT THIS TO PRISMARINE - You may ask for help on Discord, but do not file an issue. These error messages can not be removed."); // Purpur // Prismarine
+        net.minecraft.server.MinecraftServer.LOGGER.error(com.mojang.logging.LogUtils.FATAL_MARKER, msg + " (" + file.toString().replaceAll(".+[\\\\/]", "") + " - " + x + "," + z + ") Go clean it up to remove this message. /minecraft:tp " + (x<<4)+" 128 "+(z<<4) + " - DO NOT REPORT THIS TO PRISMARINE - You may ask for help on Discord, but do not file an issue. These error messages can not be removed."); // Purpur // Prismarine - JettPack patches (Remove unnecessary getLogger())
     }
 
     private static final int DEFAULT_SIZE_THRESHOLD = 1024 * 8;
diff --git a/src/main/java/net/minecraft/world/level/entity/EntitySectionStorage.java b/src/main/java/net/minecraft/world/level/entity/EntitySectionStorage.java
index 4c1e7c219e1ca153be4423347bd239ebaec4a31d..1e34e7d81dd4aa3a47be6cadfadd9c0f16c781b1 100644
--- a/src/main/java/net/minecraft/world/level/entity/EntitySectionStorage.java
+++ b/src/main/java/net/minecraft/world/level/entity/EntitySectionStorage.java
@@ -32,34 +32,66 @@ public class EntitySectionStorage<T extends EntityAccess> {
         this.intialSectionVisibility = chunkStatusDiscriminator;
     }
 
+    // Prismarine start - JettPack patches (lithium: entity.fast_retrieval)
     public void forEachAccessibleNonEmptySection(AABB box, Consumer<EntitySection<T>> action) {
-        int i = 2;
-        int j = SectionPos.posToSectionCoord(box.minX - 2.0D);
-        int k = SectionPos.posToSectionCoord(box.minY - 4.0D);
-        int l = SectionPos.posToSectionCoord(box.minZ - 2.0D);
-        int m = SectionPos.posToSectionCoord(box.maxX + 2.0D);
-        int n = SectionPos.posToSectionCoord(box.maxY + 0.0D);
-        int o = SectionPos.posToSectionCoord(box.maxZ + 2.0D);
-
-        for(int p = j; p <= m; ++p) {
-            long q = SectionPos.asLong(p, 0, 0);
-            long r = SectionPos.asLong(p, -1, -1);
-            LongIterator longIterator = this.sectionIds.subSet(q, r + 1L).iterator();
-
-            while(longIterator.hasNext()) {
-                long s = longIterator.nextLong();
-                int t = SectionPos.y(s);
-                int u = SectionPos.z(s);
-                if (t >= k && t <= n && u >= l && u <= o) {
-                    EntitySection<T> entitySection = this.sections.get(s);
-                    if (entitySection != null && !entitySection.isEmpty() && entitySection.getStatus().isAccessible()) {
-                        action.accept(entitySection);
+        int minX = SectionPos.posToSectionCoord(box.minX - 2.0D);
+        int minY = SectionPos.posToSectionCoord(box.minY - 2.0D);
+        int minZ = SectionPos.posToSectionCoord(box.minZ - 2.0D);
+        int maxX = SectionPos.posToSectionCoord(box.maxX + 2.0D);
+        int maxY = SectionPos.posToSectionCoord(box.maxY + 2.0D);
+        int maxZ = SectionPos.posToSectionCoord(box.maxZ + 2.0D);
+
+        if (maxX >= minX + 4 || maxZ >= minZ + 4) {
+            // [VanillaCopy]
+            for(int o = minX; o <= maxX; ++o) {
+                long p = SectionPos.asLong(o, 0, 0);
+                long q = SectionPos.asLong(o, -1, -1);
+                LongIterator longIterator = this.sectionIds.subSet(p, q + 1L).iterator();
+
+                while(longIterator.hasNext()) {
+                    long r = longIterator.nextLong();
+                    int s = SectionPos.y(r);
+                    int t = SectionPos.z(r);
+                    if (s >= minY && s <= maxY && t >= minZ && t <= maxZ) {
+                        EntitySection<T> entitySection = this.sections.get(r);
+                        if (entitySection != null && !entitySection.isEmpty() && entitySection.getStatus().isAccessible()) {
+                            action.accept(entitySection);
+                        }
                     }
                 }
             }
+        } else {
+            for (int x = minX; x <= maxX; x++) {
+                for (int z = Math.max(minZ, 0); z <= maxZ; z++) {
+                    this.forEachInColumn(x, minY, maxY, z, action);
+                }
+
+                int bound = Math.min(-1, maxZ);
+                for (int z = minZ; z <= bound; z++) {
+                    this.forEachInColumn(x, minY, maxY, z, action);
+                }
+            }
         }
+    }
 
+    private void forEachInColumn(int x, int minY, int maxY, int z, Consumer<EntitySection<T>> action) {
+        //y from negative to positive, but y is treated as unsigned
+        for (int y = Math.max(minY, 0); y <= maxY; y++) {
+            this.consumeSection(SectionPos.asLong(x, y, z), action);
+        }
+        int bound = Math.min(-1, maxY);
+        for (int y = minY; y <= bound; y++) {
+            this.consumeSection(SectionPos.asLong(x, y, z), action);
+        }
+    }
+
+    private void consumeSection(long pos, Consumer<EntitySection<T>> action) {
+        EntitySection<T> section = this.getSection(pos);
+        if (section != null && 0 != section.size() && section.getStatus().isAccessible()) {
+            action.accept(section);
+        }
     }
+    // Prismarine end
 
     public LongStream getExistingSectionPositionsInChunk(long chunkPos) {
         int i = ChunkPos.getX(chunkPos);
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/OreFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/OreFeature.java
index b2f36a998437e2a63a3cbc6c3aa95b1402bff2f1..e33d239156ca1e7ab68d7c0cad8886e0beef1d60 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/OreFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/OreFeature.java
@@ -54,7 +54,7 @@ public class OreFeature extends Feature<OreConfiguration> {
 
     protected boolean doPlace(WorldGenLevel world, RandomSource randomSource, OreConfiguration config, double startX, double endX, double startZ, double endZ, double startY, double endY, int x, int y, int z, int horizontalSize, int verticalSize) {
         int i = 0;
-        BitSet bitSet = new BitSet(horizontalSize * verticalSize * horizontalSize);
+        BitSet bitSet = com.ishland.c2me.opts.allocs.common.ObjectCachingUtils.getCachedOrNewBitSet(horizontalSize * verticalSize * horizontalSize); // Prismarine - JettPack patches (0057)
         BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos();
         int j = config.size;
         double[] ds = new double[j * 4];
diff --git a/src/main/java/net/minecraft/world/level/levelgen/synth/ImprovedNoise.java b/src/main/java/net/minecraft/world/level/levelgen/synth/ImprovedNoise.java
index fb84d703b4461343d50510d7c9be32fc1f09ed22..e9244efa122a9fa39dc36792af4c755dce70fa2b 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/synth/ImprovedNoise.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/synth/ImprovedNoise.java
@@ -11,6 +11,27 @@ public final class ImprovedNoise {
     public final double yo;
     public final double zo;
 
+    // Prismarine start - JettPack patches (C2ME math optimizations)
+    private static final double[][] SIMPLEX_NOISE_GRADIENTS = new double[][]{
+            {1, 1, 0},
+            {-1, 1, 0},
+            {1, -1, 0},
+            {-1, -1, 0},
+            {1, 0, 1},
+            {-1, 0, 1},
+            {1, 0, -1},
+            {-1, 0, -1},
+            {0, 1, 1},
+            {0, -1, 1},
+            {0, 1, -1},
+            {0, -1, -1},
+            {1, 1, 0},
+            {0, -1, 1},
+            {-1, 1, 0},
+            {0, -1, -1}
+    };
+    // Prismarine end
+
     public ImprovedNoise(RandomSource random) {
         this.xo = random.nextDouble() * 256.0D;
         this.yo = random.nextDouble() * 256.0D;
@@ -40,27 +61,23 @@ public final class ImprovedNoise {
         double d = x + this.xo;
         double e = y + this.yo;
         double f = z + this.zo;
-        int i = Mth.floor(d);
-        int j = Mth.floor(e);
-        int k = Mth.floor(f);
-        double g = d - (double)i;
-        double h = e - (double)j;
-        double l = f - (double)k;
-        double o;
-        if (yScale != 0.0D) {
+        // Prismarine start - JettPack patches (C2ME math optimizations)
+        double i = Mth.floor(d);
+        double j = Mth.floor(e);
+        double k = Mth.floor(f);
+        double h = e - j;
+        double o = 0.0D;
+        if (yScale != 0.0) {
             double m;
-            if (yMax >= 0.0D && yMax < h) {
+            if (yMax >= 0.0 && yMax < h) {
                 m = yMax;
             } else {
                 m = h;
             }
-
-            o = (double)Mth.floor(m / yScale + (double)1.0E-7F) * yScale;
-        } else {
-            o = 0.0D;
+            o = Mth.floor(m / yScale + 1.0E-7F) * yScale;
         }
-
-        return this.sampleAndLerp(i, j, k, g, h - o, l, h);
+        return this.sampleAndLerp((int) i, (int) j, (int) k, d - i, h - o, f - k, h);
+        // Prismarine end
     }
 
     public double noiseWithDerivative(double x, double y, double z, double[] ds) {
@@ -85,24 +102,35 @@ public final class ImprovedNoise {
     }
 
     private double sampleAndLerp(int sectionX, int sectionY, int sectionZ, double localX, double localY, double localZ, double fadeLocalY) {
-        int i = this.p(sectionX);
-        int j = this.p(sectionX + 1);
-        int k = this.p(i + sectionY);
-        int l = this.p(i + sectionY + 1);
-        int m = this.p(j + sectionY);
-        int n = this.p(j + sectionY + 1);
-        double d = gradDot(this.p(k + sectionZ), localX, localY, localZ);
-        double e = gradDot(this.p(m + sectionZ), localX - 1.0D, localY, localZ);
-        double f = gradDot(this.p(l + sectionZ), localX, localY - 1.0D, localZ);
-        double g = gradDot(this.p(n + sectionZ), localX - 1.0D, localY - 1.0D, localZ);
-        double h = gradDot(this.p(k + sectionZ + 1), localX, localY, localZ - 1.0D);
-        double o = gradDot(this.p(m + sectionZ + 1), localX - 1.0D, localY, localZ - 1.0D);
-        double p = gradDot(this.p(l + sectionZ + 1), localX, localY - 1.0D, localZ - 1.0D);
-        double q = gradDot(this.p(n + sectionZ + 1), localX - 1.0D, localY - 1.0D, localZ - 1.0D);
-        double r = Mth.smoothstep(localX);
-        double s = Mth.smoothstep(fadeLocalY);
-        double t = Mth.smoothstep(localZ);
-        return Mth.lerp3(r, s, t, d, e, f, g, h, o, p, q);
+        // Prismarine start - JettPack patches (C2ME math optimizations)
+        final int var1 = this.p[sectionX & 0xFF] & 0xFF;
+        final int var2 = this.p[(sectionX + 1) & 0xFF] & 0xFF;
+        final int var3 = this.p[(var1 + sectionY) & 0xFF] & 0xFF;
+        final int var4 = this.p[(var1 + sectionY + 1) & 0xFF] & 0xFF;
+        final int var5 = this.p[(var2 + sectionY) & 0xFF] & 0xFF;
+        final int var6 = this.p[(var2 + sectionY + 1) & 0xFF] & 0xFF;
+        final double[] var7 = SIMPLEX_NOISE_GRADIENTS[this.p[(var3 + sectionZ) & 0xFF] & 15];
+        final double[] var8 = SIMPLEX_NOISE_GRADIENTS[this.p[(var5 + sectionZ) & 0xFF] & 15];
+        final double[] var9 = SIMPLEX_NOISE_GRADIENTS[this.p[(var4 + sectionZ) & 0xFF] & 15];
+        final double[] var10 = SIMPLEX_NOISE_GRADIENTS[this.p[(var6 + sectionZ) & 0xFF] & 15];
+        final double[] var11 = SIMPLEX_NOISE_GRADIENTS[this.p[(var3 + sectionZ + 1) & 0xFF] & 15];
+        final double[] var12 = SIMPLEX_NOISE_GRADIENTS[this.p[(var5 + sectionZ + 1) & 0xFF] & 15];
+        final double[] var13 = SIMPLEX_NOISE_GRADIENTS[this.p[(var4 + sectionZ + 1) & 0xFF] & 15];
+        final double[] var14 = SIMPLEX_NOISE_GRADIENTS[this.p[(var6 + sectionZ + 1) & 0xFF] & 15];
+        final double var15 = localX - 1.0;
+        final double var16 = localY - 1.0;
+        final double var17 = localZ - 1.0;
+        final double var18 = (var7[0] * localX) + (var7[1] * localY) + (var7[2] * localZ);
+        final double var19 = (var9[0] * localX) + (var9[1] * var16) + (var9[2] * localZ);
+        final double var20 = (var11[0] * localX) + (var11[1] * localY) + (var11[2] * var17);
+        final double var21 = (var13[0] * localX) + (var13[1] * var16) + (var13[2] * var17);
+        final double var22 = localX * localX * localX * (localX * (localX * 6.0 - 15.0) + 10.0);
+        final double var23 = fadeLocalY * fadeLocalY * fadeLocalY * (fadeLocalY * (fadeLocalY * 6.0 - 15.0) + 10.0);
+        final double var24 = var18 + (var22 * (((var8[0] * var15) + (var8[1] * localY) + (var8[2] * localZ)) - var18));
+        final double var25 = var20 + (var22 * (((var12[0] * var15) + (var12[1] * localY) + (var12[2] * var17)) - var20));
+        final double var26 = var24 + (var23 * ((var19 + (var22 * (((var10[0] * var15) + (var10[1] * var16) + (var10[2] * localZ)) - var19))) - var24));
+        return var26 + ((localZ * localZ * localZ * (localZ * (localZ * 6.0 - 15.0) + 10.0)) * ((var25 + (var23 * ((var21 + (var22 * (((var14[0] * var15) + (var14[1] * var16) + (var14[2] * var17)) - var21))) - var25))) - var26));
+        // Prismarine end
     }
 
     private double sampleWithDerivative(int sectionX, int sectionY, int sectionZ, double localX, double localY, double localZ, double[] ds) {
diff --git a/src/main/java/net/minecraft/world/level/levelgen/synth/PerlinNoise.java b/src/main/java/net/minecraft/world/level/levelgen/synth/PerlinNoise.java
index 03c752e4abfe9e1f27c79024af48b31f7e90e555..b58a52f946b7b67ef8dc917167e1669e8e05fe08 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/synth/PerlinNoise.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/synth/PerlinNoise.java
@@ -192,7 +192,7 @@ public class PerlinNoise {
     }
 
     public static double wrap(double value) {
-        return value - (double)Mth.lfloor(value / 3.3554432E7D + 0.5D) * 3.3554432E7D;
+        return value - Mth.lfloor(value / 3.3554432E7 + 0.5) * 3.3554432E7; // Prismarine - JettPack patches (C2ME math optimizations)
     }
 
     protected int firstOctave() {
diff --git a/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java b/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java
index 2bb24bf628a37c79e337f1cba99b816465ecb723..bb23784a480d9ca6e1246260e724a42073bb636a 100644
--- a/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java
+++ b/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java
@@ -24,6 +24,7 @@ public class PlayerDataStorage {
     private static final Logger LOGGER = LogUtils.getLogger();
     private final File playerDir;
     protected final DataFixer fixerUpper;
+    private final me.titaniumtown.cache.NBTCache dataCache = new me.titaniumtown.cache.NBTCache(); // JettPack - NBT Cache system
 
     public PlayerDataStorage(LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer) {
         this.fixerUpper = dataFixer;
@@ -37,11 +38,27 @@ public class PlayerDataStorage {
             CompoundTag nbttagcompound = player.saveWithoutId(new CompoundTag());
             File file = File.createTempFile(player.getStringUUID() + "-", ".dat", this.playerDir);
 
-            NbtIo.writeCompressed(nbttagcompound, file);
-            File file1 = new File(this.playerDir, player.getStringUUID() + ".dat");
-            File file2 = new File(this.playerDir, player.getStringUUID() + ".dat_old");
+            // Prismarine start - JettPack patches
+            Runnable task = () -> {
+                try {
+                    NbtIo.writeCompressed(nbttagcompound, file);
+                    File file1 = new File(this.playerDir, player.getStringUUID() + ".dat");
+                    File file2 = new File(this.playerDir, player.getStringUUID() + ".dat_old");
 
-            Util.safeReplaceFile(file1, file, file2);
+                    Util.safeReplaceFile(file1, file, file2);
+                } catch (Exception exception) {
+                    LOGGER.error("Failed to save player data for {}", player.getName(), exception);
+                }
+            };
+            synchronized (this.dataCache) {
+                this.dataCache.put(file, nbttagcompound);
+            }
+            if (net.prismarineteam.prismarine.PrismarineConfig.useYatopiaAsyncNBTCache) {
+                io.papermc.paper.util.MCUtil.asyncExecutor.execute(task);
+            } else {
+                task.run();
+            }
+            // Prismarine end
         } catch (Exception exception) {
             PlayerDataStorage.LOGGER.warn("Failed to save player data for {}", player.getScoreboardName(), exception); // Paper
         }
@@ -57,9 +74,20 @@ public class PlayerDataStorage {
             // Spigot Start
             boolean usingWrongFile = false;
             boolean normalFile = file.exists() && file.isFile(); // Akarin - ensures normal file // Prismarine - Akarin patches
-            if ( org.bukkit.Bukkit.getOnlineMode() && !normalFile ) // Paper - Check online mode first // Akarin - ensures normal file // Prismarine - Akarin patches
+            // Prismarine start - JettPack patches
+            CompoundTag playerData;
+            synchronized (this.dataCache) {
+                playerData = this.dataCache.get(file);
+            }
+            if ( playerData == null && org.bukkit.Bukkit.getOnlineMode() && !normalFile ) // Paper - Check online mode first // Akarin - ensures normal file // Prismarine - Akarin patches
+            // Prismarine end
             {
                 file = new File( this.playerDir, java.util.UUID.nameUUIDFromBytes( ( "OfflinePlayer:" + player.getScoreboardName() ).getBytes( "UTF-8" ) ).toString() + ".dat");
+                // Prismarne start - JettPack patches
+                synchronized (this.dataCache) {
+                    playerData = this.dataCache.get(file);
+                }
+                // Prismarine end
                 if ( file.exists() )
                 {
                     usingWrongFile = true;
@@ -68,6 +96,11 @@ public class PlayerDataStorage {
             }
             // Spigot End
 
+            // Prismarine start - JettPack patches
+            if (playerData != null) {
+                nbttagcompound = playerData;
+            } else
+            // Prismarine end
             if (normalFile) { // Akarin - ensures normal file // Prismarine - Akarin patches
                 nbttagcompound = NbtIo.readCompressed(file);
             }
diff --git a/src/main/java/net/minecraft/world/phys/AABB.java b/src/main/java/net/minecraft/world/phys/AABB.java
index cfb2e46b34b2982d6724f18214557fc80cf4adfa..07b0d7a4dcac08b68099b5e1c26675c3ad460e94 100644
--- a/src/main/java/net/minecraft/world/phys/AABB.java
+++ b/src/main/java/net/minecraft/world/phys/AABB.java
@@ -16,6 +16,15 @@ public class AABB {
     public final double maxY;
     public final double maxZ;
 
+    // Prismarine start - JettPack patches (lithium: fast_util)
+    static {
+        assert Direction.Axis.X.ordinal() == 0;
+        assert Direction.Axis.Y.ordinal() == 1;
+        assert Direction.Axis.Z.ordinal() == 2;
+        assert Direction.Axis.values().length == 3;
+    }
+    // Prismarine ned
+
     public AABB(double x1, double y1, double z1, double x2, double y2, double z2) {
         this.minX = Math.min(x1, x2);
         this.minY = Math.min(y1, y2);
@@ -81,11 +90,31 @@ public class AABB {
     }
 
     public double min(Direction.Axis axis) {
-        return axis.choose(this.minX, this.minY, this.minZ);
+        // Prismarine start - JettPack patches (lithium: fast_util)
+        switch (axis.ordinal()) {
+            case 0:
+                return this.minX;
+            case 1:
+                return this.minY;
+            case 2:
+                return this.minZ;
+        }
+        throw new IllegalArgumentException();
+        // Prismarine end
     }
 
     public double max(Direction.Axis axis) {
-        return axis.choose(this.maxX, this.maxY, this.maxZ);
+        // Prismarine start - JettPack patches (lithium: fast_util)
+        switch (axis.ordinal()) {
+            case 0:
+                return this.minX;
+            case 1:
+                return this.minY;
+            case 2:
+                return this.minZ;
+        }
+        throw new IllegalArgumentException();
+        // Prismarine end
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/phys/shapes/CubePointRange.java b/src/main/java/net/minecraft/world/phys/shapes/CubePointRange.java
index a544db042c8d2ecec8d323770552c4f10ca758a6..c04da8da5b40430b61972bce32cec4e8c0370bac 100644
--- a/src/main/java/net/minecraft/world/phys/shapes/CubePointRange.java
+++ b/src/main/java/net/minecraft/world/phys/shapes/CubePointRange.java
@@ -4,6 +4,7 @@ import it.unimi.dsi.fastutil.doubles.AbstractDoubleList;
 
 public class CubePointRange extends AbstractDoubleList {
     private final int parts;
+    private double scale; // JettPack - lithium: shapes.precompute_shape_arrays
 
     CubePointRange(int sectionCount) {
         if (sectionCount <= 0) {
@@ -11,10 +12,11 @@ public class CubePointRange extends AbstractDoubleList {
         } else {
             this.parts = sectionCount;
         }
+        this.scale = 1.0D / sectionCount; // JettPack - lithium: shapes.precompute_shape_arrays
     }
 
     public double getDouble(int i) {
-        return (double)i / (double)this.parts;
+        return i * this.scale; // JettPack - lithium: shapes.precompute_shape_arrays
     }
 
     public int size() {
diff --git a/src/main/java/net/minecraft/world/phys/shapes/CubeVoxelShape.java b/src/main/java/net/minecraft/world/phys/shapes/CubeVoxelShape.java
index 68e89dbd79171627046e89699057964e44c40e7d..959588962acb0196ec9f1cc2502e62117f6ccdc4 100644
--- a/src/main/java/net/minecraft/world/phys/shapes/CubeVoxelShape.java
+++ b/src/main/java/net/minecraft/world/phys/shapes/CubeVoxelShape.java
@@ -3,15 +3,25 @@ package net.minecraft.world.phys.shapes;
 import it.unimi.dsi.fastutil.doubles.DoubleList;
 import net.minecraft.core.Direction;
 import net.minecraft.util.Mth;
+import net.minecraft.world.phys.shapes.CubePointRange; // JettPack
 
 public final class CubeVoxelShape extends VoxelShape {
+    private DoubleList[] list; // JettPack - lithium: shapes.precompute_shape_arrays
+
     protected CubeVoxelShape(DiscreteVoxelShape voxels) {
         super(voxels);
+        // JettPack start - lithium: shapes.precompute_shape_arrays
+        this.list = new DoubleList[Direction.VALUES.length];
+
+        for (Direction.Axis axis : Direction.Axis.VALUES) {
+            this.list[axis.ordinal()] = new CubePointRange(voxels.getSize(axis));
+        }
+        // JettPack end
     }
 
     @Override
     protected DoubleList getCoords(Direction.Axis axis) {
-        return new CubePointRange(this.shape.getSize(axis));
+        return this.list[axis.ordinal()]; // JettPack - lithium: shapes.precompute_shape_arrays
     }
 
     @Override
diff --git a/src/main/java/net/prismarineteam/prismarine/PrismarineConfig.java b/src/main/java/net/prismarineteam/prismarine/PrismarineConfig.java
index eb01aab61aa3383e39120c7dfb60d9c9a4b801d1..ed3de4464f32cc75fd3cf5e1d90d65c971db1484 100644
--- a/src/main/java/net/prismarineteam/prismarine/PrismarineConfig.java
+++ b/src/main/java/net/prismarineteam/prismarine/PrismarineConfig.java
@@ -154,4 +154,55 @@ public class PrismarineConfig {
             set("settings.patina-settings.disable-bootstrap-executor", null);
         }
     }
+
+    public static boolean useJettPackAsyncExecutor = true;
+    private static void JettPackPatches() {
+        useJettPackAsyncExecutor = getBoolean("settings.use-jettpack-async-executor", useJettPackAsyncExecutor);
+        if (version < 3) {
+            set("settings.use-jettpack-async-executor", getBoolean("settings.jettpack-patches.use-jettpack-async-executor", true));
+            set("settings.jettpack-patches.use-jettpack-async-executor", null);
+        }
+    }
+
+    public static boolean useYatopiaAsyncNBTCache = false;
+    private static void useYatopiaAsyncNBTCache() {
+        useYatopiaAsyncNBTCache = getBoolean("settings.use-yatopia-async-nbt-cache", useYatopiaAsyncNBTCache);
+        if (version < 3) {
+            set("settings.use-yatopia-async-nbt-cache", getBoolean("settings.jettpack-patches.use-yatopia-async-nbt-cache", false));
+            set("settings.jettpack-patches.use-yatopia-async-nbt-cache", null);
+        }
+    }
+
+    public static boolean logPlayerLoginLocation = true;
+    private static void logPlayerLoginLocation() {
+        logPlayerLoginLocation = getBoolean("settings.log-player-login-location", logPlayerLoginLocation);
+    }
+
+    public static boolean useLithiumCosine = true;
+    public static boolean useLithiumSine = true;
+    public static boolean useLithiumAttributes = true;
+    public static boolean useLithiumEntityByType = true;
+    public static boolean useLithiumEntityFiltering = true;
+    private static void useLithiumMath() {
+        useLithiumCosine = getBoolean("settings.lithium.math.cosine", useLithiumCosine);
+        useLithiumSine = getBoolean("settings.lithium.math.sine", useLithiumSine);
+        useLithiumAttributes = getBoolean("settings.lithium.attributes", useLithiumAttributes);
+        useLithiumEntityByType = getBoolean("settings.lithium.collections.entity_by_type", useLithiumEntityByType);
+        useLithiumEntityFiltering = getBoolean("settings.lithium.collections.entity_filtering", useLithiumEntityFiltering);
+    }
+
+    public static boolean fastHandSwing = true;
+    private static void fastHandSwing() {
+        fastHandSwing = getBoolean("settings.fast-hand-swing", fastHandSwing);
+    }
+
+    public static boolean useAsyncExecutorAtAuthencatorPool = false;
+    private static void useAsyncExecutorAtAuthencatorPool() {
+        useAsyncExecutorAtAuthencatorPool = getBoolean("settings.use-async-executor-at-authencator-pool", useAsyncExecutorAtAuthencatorPool);
+    }
+
+    public static boolean useExperimentalVMPIngredientMatchingCache = false;
+    private static void useExperimentalVMPIngredientMatchingCache() {
+        useExperimentalVMPIngredientMatchingCache = getBoolean("settings.use-experimental-vmp-ingredient-matching-cache", useExperimentalVMPIngredientMatchingCache);
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/net/prismarineteam/prismarine/PrismarineWorldConfig.java b/src/main/java/net/prismarineteam/prismarine/PrismarineWorldConfig.java
index cf494171713b5fc12e9627774f2705b911b54bd2..17471282fd5820705b24a88888495d33d81b492c 100644
--- a/src/main/java/net/prismarineteam/prismarine/PrismarineWorldConfig.java
+++ b/src/main/java/net/prismarineteam/prismarine/PrismarineWorldConfig.java
@@ -74,4 +74,14 @@ public class PrismarineWorldConfig {
         final Map<String, Object> value = PrismarineConfig.getMap("world-settings." + worldName + "." + path, null);
         return value.isEmpty() ? fallback : value;
     }
+    
+    public double fishingRodLength = 1024.0D;
+    private void fishingRodLength() {
+        fishingRodLength = getDouble("fishing-rod-length", fishingRodLength);
+    }
+
+    public boolean despawnMobWhenNoPlayerIsOnRange = false;
+    private void despawnMobWhenNoPlayerIsOnRange() {
+        despawnMobWhenNoPlayerIsOnRange = getBoolean("despawn-mob-when-no-player-is-on-range", despawnMobWhenNoPlayerIsOnRange);
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftAsyncScheduler.java b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftAsyncScheduler.java
index 9c1aff17aabd062640e3f451a2ef8c50a7c62f10..5bd196e7e64e3f3e735b8cd5b82563cfec73924d 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftAsyncScheduler.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftAsyncScheduler.java
@@ -38,17 +38,21 @@ import java.util.concurrent.TimeUnit;
 
 public class CraftAsyncScheduler extends CraftScheduler {
 
+    /* // Prismarine - JettPack patches
     private final ThreadPoolExecutor executor = new ThreadPoolExecutor(
             4, Integer.MAX_VALUE,30L, TimeUnit.SECONDS, new SynchronousQueue<>(),
             new ThreadFactoryBuilder().setNameFormat("Craft Scheduler Thread - %1$d").setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(net.minecraft.server.MinecraftServer.LOGGER)).build()); // Paper
+    */ // Prismarine - JettPack patches
     private final Executor management = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder()
             .setNameFormat("Craft Async Scheduler Management Thread").setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(net.minecraft.server.MinecraftServer.LOGGER)).build()); // Paper
     private final List<CraftTask> temp = new ArrayList<>();
 
     CraftAsyncScheduler() {
         super(true);
+        /* // Prismarine - JettPack patches
         executor.allowCoreThreadTimeOut(true);
         executor.prestartAllCoreThreads();
+         */ // Prismarine - JettPack patches
     }
 
     @Override
@@ -93,7 +97,7 @@ public class CraftAsyncScheduler extends CraftScheduler {
     private boolean executeTask(CraftTask task) {
         if (isValid(task)) {
             this.runners.put(task.getTaskId(), task);
-            this.executor.execute(new ServerSchedulerReportingWrapper(task));
+            io.papermc.paper.util.MCUtil.asyncExecutor.execute(new ServerSchedulerReportingWrapper(task)); // Jettpack // Prismarine - JettPack patches
             return true;
         }
         return false;
diff --git a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
index 2d90a7cf5d5de95005724fabcf7362bf7b555f6e..72ed3ff31682673c045be76bf5329894704b84d0 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
@@ -8,8 +8,11 @@ import java.util.logging.Logger;
 import org.bukkit.Bukkit;
 
 public final class Versioning {
-    public static String getBukkitVersion() {
-        String result = "Unknown-Version";
+    // Prismarine start - JettPack patches
+    public static String bukkitVersion;
+    static {
+        bukkitVersion = "Unknown-Version";
+    // Prismarine end
 
         InputStream stream = Bukkit.class.getClassLoader().getResourceAsStream("META-INF/maven/net.prismarineteam.prismarine/Prismarine-API/pom.properties"); // Purpur // Prismarine
         Properties properties = new Properties();
@@ -18,12 +21,16 @@ public final class Versioning {
             try {
                 properties.load(stream);
 
-                result = properties.getProperty("version");
+                bukkitVersion = properties.getProperty("version"); // Prismarine - JettPack patches
             } catch (IOException ex) {
                 Logger.getLogger(Versioning.class.getName()).log(Level.SEVERE, "Could not get Prismarine version!", ex); // Prismarine
             }
         }
+    }
 
-        return result;
+    // Prismarine start - JettPack patches
+    public static String getBukkitVersion() {
+        return bukkitVersion;
     }
+    // Prismarine end
 }
diff --git a/src/main/java/org/spigotmc/WatchdogThread.java b/src/main/java/org/spigotmc/WatchdogThread.java
index e34254283a7c0b05d652dadddab92627b7899e89..e27dec3ab8c5fd23ab8ae735f8996bf04b3afe3c 100644
--- a/src/main/java/org/spigotmc/WatchdogThread.java
+++ b/src/main/java/org/spigotmc/WatchdogThread.java
@@ -140,7 +140,7 @@ public final class WatchdogThread extends io.papermc.paper.util.TickThread // Pa
     {
         while ( !this.stopping )
         {
-            //
+            io.papermc.paper.util.MCUtil.flushAsyncTasks(); // Jettpack // Prismarine - JettPack patches
             // Paper start
             Logger log = Bukkit.getServer().getLogger();
             long currentTime = WatchdogThread.monotonicMillis();
