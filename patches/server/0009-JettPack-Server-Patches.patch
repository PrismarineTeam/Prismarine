From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: AlphaKR93 <alphakr93@outlook.com>
Date: Mon, 4 Jul 2022 13:08:16 +0900
Subject: [PATCH] JettPack Server Patches

Original by Simon Gardling <titaniumtown@gmail.com>

Copyright (C) JettPackMC LLC

This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation, either version 3 of the License, or (at your
option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program. If not, see <http://www.gnu.org/licenses/>.

[ADDED PATCHES]
0003
0005
0008
0009
0011
0012
0013
0014
0020
0021
0022
0023
0027
0028
0029
0031
0035
0038
0040
0041
0042
0043

diff --git a/src/main/java/me/jellysquid/mods/lithium/common/util/collections/HashedList.java b/src/main/java/me/jellysquid/mods/lithium/common/util/collections/HashedList.java
new file mode 100644
index 0000000000000000000000000000000000000000..593f429a230b5056169be4e552791f77175d10f9
--- /dev/null
+++ b/src/main/java/me/jellysquid/mods/lithium/common/util/collections/HashedList.java
@@ -0,0 +1,280 @@
+package me.jellysquid.mods.lithium.common.util.collections;
+
+import it.unimi.dsi.fastutil.objects.Reference2IntOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ReferenceArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.NoSuchElementException;
+
+/**
+ * Wraps a {@link List} with a hash table which provides O(1) lookups for {@link Collection#contains(Object)}. The type
+ * contained by this list must use reference-equality semantics.
+ */
+@SuppressWarnings("SuspiciousMethodCalls")
+public class HashedList<T> implements List<T> {
+    private final ReferenceArrayList<T> list;
+    private final Reference2IntOpenHashMap<T> counter;
+
+    public HashedList(List<T> list) {
+        this.list = new ReferenceArrayList<>();
+        this.list.addAll(list);
+
+        this.counter = new Reference2IntOpenHashMap<>();
+        this.counter.defaultReturnValue(0);
+
+        for (T obj : this.list) {
+            this.counter.addTo(obj, 1);
+        }
+    }
+
+    @Override
+    public int size() {
+        return this.list.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return this.list.isEmpty();
+    }
+
+    @Override
+    public boolean contains(Object o) {
+        return this.counter.containsKey(o);
+    }
+
+    @Override
+    public Iterator<T> iterator() {
+        return this.listIterator();
+    }
+
+    @Override
+    public Object[] toArray() {
+        return this.list.toArray();
+    }
+
+    @SuppressWarnings("SuspiciousToArrayCall")
+    @Override
+    public <T1> T1[] toArray(T1[] a) {
+        return this.list.toArray(a);
+    }
+
+    @Override
+    public boolean add(T t) {
+        this.trackReferenceAdded(t);
+
+        return this.list.add(t);
+    }
+
+    @Override
+    public boolean remove(Object o) {
+        this.trackReferenceRemoved(o);
+
+        return this.list.remove(o);
+    }
+
+    @Override
+    public boolean containsAll(Collection<?> c) {
+        for (Object obj : c) {
+            if (!this.counter.containsKey(obj)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    @Override
+    public boolean addAll(Collection<? extends T> c) {
+        for (T obj : c) {
+            this.trackReferenceAdded(obj);
+        }
+
+        return this.list.addAll(c);
+    }
+
+    @Override
+    public boolean addAll(int index, Collection<? extends T> c) {
+        for (T obj : c) {
+            this.trackReferenceAdded(obj);
+        }
+
+        return this.list.addAll(index, c);
+    }
+
+    @Override
+    public boolean removeAll(Collection<?> c) {
+        for (Object obj : c) {
+            this.trackReferenceRemoved(obj);
+        }
+
+        return this.list.removeAll(c);
+    }
+
+    @Override
+    public boolean retainAll(Collection<?> c) {
+        return this.list.retainAll(c);
+    }
+
+    @Override
+    public void clear() {
+        this.counter.clear();
+        this.list.clear();
+    }
+
+    @Override
+    public T get(int index) {
+        return this.list.get(index);
+    }
+
+    @Override
+    public T set(int index, T element) {
+        T prev = this.list.set(index, element);
+
+        if (prev != element) {
+            if (prev != null) {
+                this.trackReferenceRemoved(prev);
+            }
+
+            this.trackReferenceAdded(element);
+        }
+
+        return prev;
+    }
+
+    @Override
+    public void add(int index, T element) {
+        this.trackReferenceAdded(element);
+
+        this.list.add(index, element);
+    }
+
+    @Override
+    public T remove(int index) {
+        T prev = this.list.remove(index);
+
+        if (prev != null) {
+            this.trackReferenceRemoved(prev);
+        }
+
+        return prev;
+    }
+
+    @Override
+    public int indexOf(Object o) {
+        return this.list.indexOf(o);
+    }
+
+    @Override
+    public int lastIndexOf(Object o) {
+        return this.list.lastIndexOf(o);
+    }
+
+    @Override
+    public ListIterator<T> listIterator() {
+        return this.listIterator(0);
+    }
+
+    @Override
+    public ListIterator<T> listIterator(int index) {
+        return new ListIterator<T>() {
+            private final ListIterator<T> inner = HashedList.this.list.listIterator(index);
+
+            @Override
+            public boolean hasNext() {
+                return this.inner.hasNext();
+            }
+
+            @Override
+            public T next() {
+                return this.inner.next();
+            }
+
+            @Override
+            public boolean hasPrevious() {
+                return this.inner.hasPrevious();
+            }
+
+            @Override
+            public T previous() {
+                return this.inner.previous();
+            }
+
+            @Override
+            public int nextIndex() {
+                return this.inner.nextIndex();
+            }
+
+            @Override
+            public int previousIndex() {
+                return this.inner.previousIndex();
+            }
+
+            @Override
+            public void remove() {
+                int last = this.previousIndex();
+
+                if (last == -1) {
+                    throw new NoSuchElementException();
+                }
+
+                T prev = HashedList.this.get(last);
+
+                if (prev != null) {
+                    HashedList.this.trackReferenceRemoved(prev);
+                }
+
+                this.inner.remove();
+            }
+
+            @Override
+            public void set(T t) {
+                int last = this.previousIndex();
+
+                if (last == -1) {
+                    throw new NoSuchElementException();
+                }
+
+                T prev = HashedList.this.get(last);
+
+                if (prev != t) {
+                    if (prev != null) {
+                        HashedList.this.trackReferenceRemoved(prev);
+                    }
+
+                    HashedList.this.trackReferenceAdded(t);
+                }
+
+                this.inner.remove();
+            }
+
+            @Override
+            public void add(T t) {
+                HashedList.this.trackReferenceAdded(t);
+
+                this.inner.add(t);
+            }
+        };
+    }
+
+    @Override
+    public List<T> subList(int fromIndex, int toIndex) {
+        return this.list.subList(fromIndex, toIndex);
+    }
+
+    private void trackReferenceAdded(T t) {
+        this.counter.addTo(t, 1);
+    }
+
+    @SuppressWarnings("unchecked")
+    private void trackReferenceRemoved(Object o) {
+        if (this.counter.addTo((T) o, -1) <= 1) {
+            this.counter.removeInt(o);
+        }
+    }
+
+    public static <T> HashedList<T> wrapper(List<T> list) {
+        return new HashedList<>(list);
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/me/jellysquid/mods/lithium/common/util/math/CompactSineLUT.java b/src/main/java/me/jellysquid/mods/lithium/common/util/math/CompactSineLUT.java
new file mode 100644
index 0000000000000000000000000000000000000000..600b30b097619c76ca95a4fdb6fb17b893e25207
--- /dev/null
+++ b/src/main/java/me/jellysquid/mods/lithium/common/util/math/CompactSineLUT.java
@@ -0,0 +1,89 @@
+package me.jellysquid.mods.lithium.common.util.math;
+
+import net.minecraft.util.Mth;
+
+/**
+ * A replacement for the sine angle lookup table used in {@link Mth}, both reducing the size of LUT and improving
+ * the access patterns for common paired sin/cos operations.
+ *
+ *  sin(-x) = -sin(x)
+ *    ... to eliminate negative angles from the LUT.
+ *
+ *  sin(x) = sin(pi/2 - x)
+ *    ... to eliminate supplementary angles from the LUT.
+ *
+ * Using these identities allows us to reduce the LUT from 64K entries (256 KB) to just 16K entries (64 KB), enabling
+ * it to better fit into the CPU's caches at the expense of some cycles on the fast path. The implementation has been
+ * tightly optimized to avoid branching where possible and to use very quick integer operations.
+ *
+ * Generally speaking, reducing the size of a lookup table is always a good optimization, but since we need to spend
+ * extra CPU cycles trying to maintain parity with vanilla, there is the potential risk that this implementation ends
+ * up being slower than vanilla when the lookup table is able to be kept in cache memory.
+ *
+ * Unlike other "fast math" implementations, the values returned by this class are *bit-for-bit identical* with those
+ * from {@link Mth}. Validation is performed during runtime to ensure that the table is correct.
+ *
+ * @author coderbot16   Author of the original (and very clever) implementation in Rust:
+ *  https://gitlab.com/coderbot16/i73/-/tree/master/i73-trig/src
+ * @author jellysquid3  Additional optimizations, port to Java
+ */
+public class CompactSineLUT {
+    private static final int[] SINE_TABLE_INT = new int[16384 + 1];
+    private static final float SINE_TABLE_MIDPOINT;
+
+    static {
+        // Copy the sine table, covering to raw int bits
+        for (int i = 0; i < SINE_TABLE_INT.length; i++) {
+            SINE_TABLE_INT[i] = Float.floatToRawIntBits(Mth.SIN[i]);
+        }
+
+        SINE_TABLE_MIDPOINT = Mth.SIN[Mth.SIN.length / 2];
+
+        // Test that the lookup table is correct during runtime
+        for (int i = 0; i < Mth.SIN.length; i++) {
+            float expected = Mth.SIN[i];
+            float value = lookup(i);
+
+            if (expected != value) {
+                throw new IllegalArgumentException(String.format("LUT error at index %d (expected: %s, found: %s)", i, expected, value));
+            }
+        }
+    }
+
+    // [VanillaCopy] MathHelper#sin(float)
+    public static float sin(float f) {
+        return lookup((int) (f * 10430.38) & 0xFFFF);
+    }
+
+    // [VanillaCopy] MathHelper#cos(float)
+    public static float cos(float f) {
+        return lookup((int) (f * 10430.38 + 16384.0) & 0xFFFF);
+    }
+
+    private static float lookup(int index) {
+        // A special case... Is there some way to eliminate this?
+        if (index == 32768) {
+            return SINE_TABLE_MIDPOINT;
+        }
+
+        // Trigonometric identity: sin(-x) = -sin(x)
+        // Given a domain of 0 <= x <= 2*pi, just negate the value if x > pi.
+        // This allows the sin table size to be halved.
+        int neg = (index & 0x8000) << 16;
+
+        // All bits set if (pi/2 <= x), none set otherwise
+        // Extracts the 15th bit from 'half'
+        int mask = (index << 17) >> 31;
+
+        // Trigonometric identity: sin(x) = sin(pi/2 - x)
+        int pos = (0x8001 & mask) + (index ^ mask);
+
+        // Wrap the position in the table. Moving this down to immediately before the array access
+        // seems to help the Hotspot compiler optimize the bit math better.
+        pos &= 0x7fff;
+
+        // Fetch the corresponding value from the LUT and invert the sign bit as needed
+        // This directly manipulate the sign bit on the float bits to simplify logic
+        return Float.intBitsToFloat(SINE_TABLE_INT[pos] ^ neg);
+    }
+}
diff --git a/src/main/java/me/titaniumtown/cache/NBTCache.java b/src/main/java/me/titaniumtown/cache/NBTCache.java
new file mode 100644
index 0000000000000000000000000000000000000000..6b416b201c370f497e2fd4368ffa0cdbb064a53e
--- /dev/null
+++ b/src/main/java/me/titaniumtown/cache/NBTCache.java
@@ -0,0 +1,32 @@
+package me.titaniumtown.cache;
+
+import it.unimi.dsi.fastutil.objects.Object2ObjectLinkedOpenCustomHashMap;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.nbt.CompoundTag;
+
+import java.io.File;
+
+public class NBTCache extends Object2ObjectLinkedOpenCustomHashMap<File, CompoundTag> {
+
+    public NBTCache() {
+        super(100, 0.75F, new Strategy<File>() {
+            @Override
+            public int hashCode(File k) {
+                return k.hashCode();
+            }
+
+            @Override
+            public boolean equals(File k, File k1) {
+                return k.equals(k1);
+            }
+        });
+    }
+
+    @Override
+    public CompoundTag put(File k, CompoundTag v) {
+        if (this.size() > MinecraftServer.getServer().getPlayerCount()) {
+            this.removeLast();
+        }
+        return super.putAndMoveToFirst(k, v);
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/me/titaniumtown/util/ServerWorkerWrapper.java b/src/main/java/me/titaniumtown/util/ServerWorkerWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..b45371f7a776451d5a15da03d130a32ff3d49e28
--- /dev/null
+++ b/src/main/java/me/titaniumtown/util/ServerWorkerWrapper.java
@@ -0,0 +1,24 @@
+package me.titaniumtown.util;
+
+import com.google.common.base.Preconditions;
+import net.minecraft.Util;
+
+public final class ServerWorkerWrapper implements Runnable {
+    private final Runnable internalRunnable;
+
+    public ServerWorkerWrapper(Runnable runnable) {
+        this.internalRunnable = Preconditions.checkNotNull(runnable, "internalRunnable");
+    }
+
+    @Override
+    public final void run() {
+        try {
+            this.internalRunnable.run();
+            return;
+        }
+        catch (Throwable throwable) {
+            Util.onThreadException(Thread.currentThread(), throwable);
+            return;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/Util.java b/src/main/java/net/minecraft/Util.java
index 3c7c3c21fe1f4ce1299274eee82884cb8aa2d2e7..bf59498b4bf57a77c337ccd6ef09239e21965148 100644
--- a/src/main/java/net/minecraft/Util.java
+++ b/src/main/java/net/minecraft/Util.java
@@ -65,9 +65,11 @@ import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
+import me.titaniumtown.util.ServerWorkerWrapper; // Prismarine - JettPack patches
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.Bootstrap;
 import net.minecraft.util.Mth;
+import net.minecraft.server.MCUtil; // Prismarine - JettPack patches
 import net.minecraft.util.RandomSource;
 import net.minecraft.util.TimeSource;
 import net.minecraft.util.datafix.DataFixers;
@@ -165,7 +167,49 @@ public class Util {
         if (i <= 0) {
             executorService = MoreExecutors.newDirectExecutorService();
         } else {
-            executorService = new java.util.concurrent.ThreadPoolExecutor(i, i,0L, TimeUnit.MILLISECONDS, new java.util.concurrent.LinkedBlockingQueue<Runnable>(), target -> new net.minecraft.server.ServerWorkerThread(target, s, priorityModifier));
+            // Prismarine start - JettPack tweaks
+            if (net.prismarineteam.prismarine.PrismarineConfig.useJettPackAsyncExecutor) {
+                executorService = Integer.getInteger("Paper.WorkerThreadCount", i) <= 0 ? MoreExecutors.newDirectExecutorService() : new java.util.concurrent.AbstractExecutorService() {
+                    private volatile boolean shutdown = false;
+
+                    @Override
+                    public final List<Runnable> shutdownNow() {
+                        this.shutdown = true;
+                        return java.util.Collections.emptyList();
+                    }
+
+                    @Override
+                    public final void shutdown() {
+                        this.shutdown = true;
+                    }
+
+                    @Override
+                    public final boolean isShutdown() {
+                        return this.shutdown;
+                    }
+
+                    @Override
+                    public final boolean isTerminated() {
+                        return this.shutdown;
+                    }
+
+                    @Override
+                    public final boolean awaitTermination(long l2, TimeUnit timeUnit) throws InterruptedException {
+                        if (!this.shutdown) {
+                            throw new UnsupportedOperationException();
+                        }
+                        return true;
+                    }
+
+                    @Override
+                    public final void execute(Runnable runnable) {
+                        MCUtil.asyncExecutor.execute(new ServerWorkerWrapper(runnable));
+                    }
+                };
+            } else {
+                executorService = new java.util.concurrent.ThreadPoolExecutor(i, i,0L, TimeUnit.MILLISECONDS, new java.util.concurrent.LinkedBlockingQueue<Runnable>(), target -> new net.minecraft.server.ServerWorkerThread(target, s, priorityModifier));
+            }
+            // Prismarine end
         }
         /*
                     @Override
diff --git a/src/main/java/net/minecraft/core/Direction.java b/src/main/java/net/minecraft/core/Direction.java
index 6c27b22dd1d497687c0f4d3835e34149bcf952c1..384ae82ca4b535e7af4ad88c498f8090f5cce322 100644
--- a/src/main/java/net/minecraft/core/Direction.java
+++ b/src/main/java/net/minecraft/core/Direction.java
@@ -41,7 +41,7 @@ public enum Direction implements StringRepresentable {
     private final Direction.Axis axis;
     private final Direction.AxisDirection axisDirection;
     private final Vec3i normal;
-    private static final Direction[] VALUES = values();
+    public static final Direction[] VALUES = values(); // JettPack - private -> public // Prismarine - JettPack patches
     private static final Direction[] BY_3D_DATA = Arrays.stream(VALUES).sorted(Comparator.comparingInt((direction) -> {
         return direction.data3d;
     })).toArray((i) -> {
@@ -196,7 +196,7 @@ public enum Direction implements StringRepresentable {
     }
 
     public Direction getOpposite() {
-        return from3DDataValue(this.oppositeIndex);
+        return VALUES[this.oppositeIndex]; // JettPack - lithium: fast_util
     }
 
     public Direction getClockWise(Direction.Axis axis) {
@@ -458,7 +458,7 @@ public enum Direction implements StringRepresentable {
     }
 
     public static Direction getRandom(RandomSource random) {
-        return Util.getRandom(VALUES, random);
+        return VALUES[random.nextInt(VALUES.length)]; // JettPack - lithium: fast_util
     }
 
     public static Direction getNearest(double x, double y, double z) {
diff --git a/src/main/java/net/minecraft/server/MCUtil.java b/src/main/java/net/minecraft/server/MCUtil.java
index e9f0ddf1a34bf3b0d868b53e4439d9d9851ad4d6..16515a5bd284e6d0ac1605e040e53f2c958f405a 100644
--- a/src/main/java/net/minecraft/server/MCUtil.java
+++ b/src/main/java/net/minecraft/server/MCUtil.java
@@ -53,9 +53,10 @@ import java.util.function.Consumer;
 import java.util.function.Supplier;
 
 public final class MCUtil {
+    public static final java.util.concurrent.ConcurrentLinkedQueue smallAsyncTasks = new java.util.concurrent.ConcurrentLinkedQueue(); // Jettpack // Prismarine - JettPack patches
     public static final ThreadPoolExecutor asyncExecutor = new ThreadPoolExecutor(
-        0, 2, 60L, TimeUnit.SECONDS,
-        new LinkedBlockingQueue<>(),
+        4, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, // JettPack // Prismarine - JettPack patches
+        new java.util.concurrent.SynchronousQueue<Runnable>(), // JettPack // Prismarine - JettPack patches
         new ThreadFactoryBuilder()
             .setNameFormat("Paper Async Task Handler Thread - %1$d")
             .setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(MinecraftServer.LOGGER))
@@ -72,6 +73,30 @@ public final class MCUtil {
 
     public static final long INVALID_CHUNK_KEY = getCoordinateKey(Integer.MAX_VALUE, Integer.MAX_VALUE);
 
+    // Prismarine start - JettPack patches
+    public static void flushAsyncTasks() {
+        if (!smallAsyncTasks.isEmpty()) {
+            asyncExecutor.submit(() -> {
+                Runnable runnable;
+                while((runnable = (Runnable)smallAsyncTasks.poll()) != null) {
+                    runnable.run();
+                }
+            });
+        }
+    }
+
+    public static void flushAsyncTasksMidTick() {
+        int i = smallAsyncTasks.size() < 16 ? smallAsyncTasks.size() : 16; // if smallAsyncTasks is over size 16, only execute 16 tasks
+        asyncExecutor.submit(() -> {
+            Runnable runnable;
+            int i_tmp = 0;
+            while((runnable = (Runnable)smallAsyncTasks.poll()) != null && i_tmp != i-1) {
+                runnable.run();
+                i_tmp += 1;
+            }
+        });
+    }
+    // Prismarine end
 
     public static Runnable once(Runnable run) {
         AtomicBoolean ran = new AtomicBoolean(false);
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 90713ba4af50af926dda8dc53fe07c08de4e6586..521741f363243fcc7d727825a0d1c84de56ac7bb 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1032,6 +1032,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         LOGGER.info("Flushing Chunk IO");
         com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.close(true, true); // Paper
         LOGGER.info("Closing Thread Pool");
+        MCUtil.flushAsyncTasks(); // Prismarine - JettPack patches
         Util.shutdownExecutors(); // Paper
         LOGGER.info("Closing Server");
         try {
@@ -1489,6 +1490,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         io.papermc.paper.util.CachedLists.reset(); // Paper
         // Paper start - move executeAll() into full server tick timing
         //try (co.aikar.timings.Timing ignored = MinecraftTimings.processTasksTimer.startTiming()) { // Purpur
+            MCUtil.flushAsyncTasks(); // Prismarine - JettPack patches
             this.runAllTasks();
         //} // Purpur
         // Paper end
@@ -2784,6 +2786,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             return;
         }
 
+        MCUtil.flushAsyncTasks(); // Prismarine - JettPack patches
         //co.aikar.timings.MinecraftTimings.midTickChunkTasks.startTiming(); // Purpur
         try {
             for (;;) {
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServerProperties.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServerProperties.java
index 01ca7156d86243a80cd343a2a66be9ebedcc3b7c..88900f7a2077049cc5d78fe17314dbdf57d64a08 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServerProperties.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServerProperties.java
@@ -137,7 +137,7 @@ public class DedicatedServerProperties extends Settings<DedicatedServerPropertie
         this.maxWorldSize = this.get("max-world-size", (integer) -> {
             return Mth.clamp(integer, (int) 1, 29999984);
         }, 29999984);
-        this.syncChunkWrites = this.get("sync-chunk-writes", true) && Boolean.getBoolean("Paper.enable-sync-chunk-writes"); // Paper - hide behind flag
+        this.syncChunkWrites = this.get("sync-chunk-writes", true) || Boolean.getBoolean("Paper.enable-sync-chunk-writes"); // Paper - hide behind flag // Prismarine - JettPack patches
         this.enableJmxMonitoring = this.get("enable-jmx-monitoring", false);
         this.enableStatus = this.get("enable-status", true);
         this.hideOnlinePlayers = this.get("hide-online-players", false);
diff --git a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
index 9e7f500e0338b70223d879df5fda47acd8843fd8..fccdcf8d47bf8a5bd462f25f4152d80d48764455 100644
--- a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
@@ -130,6 +130,7 @@ public class ServerLoginPacketListenerImpl implements TickablePacketListener, Se
 
     }
 
+    /* // Prismarine - JettPack patches
     // Paper start - Cache authenticator threads
     private static final AtomicInteger threadId = new AtomicInteger(0);
     private static final java.util.concurrent.ExecutorService authenticatorPool = java.util.concurrent.Executors.newCachedThreadPool(
@@ -142,6 +143,7 @@ public class ServerLoginPacketListenerImpl implements TickablePacketListener, Se
             }
     );
     // Paper end
+    */ // Prismarine end
     // Spigot start
     public void initUUID()
     {
@@ -315,7 +317,7 @@ public class ServerLoginPacketListenerImpl implements TickablePacketListener, Se
                 // Paper end
                 // Spigot start
             // Paper start - Cache authenticator threads
-            authenticatorPool.execute(new Runnable() {
+            net.minecraft.server.MCUtil.asyncExecutor.execute(new Runnable() { // Prismarine - JettPack patches
                     @Override
                     public void run() {
                         try {
@@ -373,7 +375,7 @@ public class ServerLoginPacketListenerImpl implements TickablePacketListener, Se
         }
 
         // Paper start - Cache authenticator threads
-        authenticatorPool.execute(new Runnable() {
+        net.minecraft.server.MCUtil.asyncExecutor.execute(new Runnable() { // Prismarine - JettPack patches
             public void run() {
                 GameProfile gameprofile = ServerLoginPacketListenerImpl.this.gameProfile;
 
@@ -523,7 +525,7 @@ public class ServerLoginPacketListenerImpl implements TickablePacketListener, Se
             }
 
             // Proceed with login
-            authenticatorPool.execute(() -> {
+            net.minecraft.server.MCUtil.asyncExecutor.execute(() -> { // Prismarine - JettPack patches
                 try {
                     new LoginHandler().fireEvents();
                 } catch (Exception ex) {
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 138b2c1a21b9ceb60030d10e24c78e09533937a0..2ac13f6d367b90ff9b66925904a650387593c4f5 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -505,7 +505,13 @@ public abstract class PlayerList {
         // Paper end
         org.purpurmc.purpur.task.BossBarTask.addToAll(player); // Purpur
         // CraftBukkit - Moved from above, added world
-        PlayerList.LOGGER.info("{}[{}] logged in with entity id {} at ([{}]{}, {}, {})", player.getName().getString(), s1, player.getId(), worldserver1.serverLevelData.getLevelName(), player.getX(), player.getY(), player.getZ());
+        // Prismarine start - JettPack patches (configurable logging of player login location)
+        if (net.prismarineteam.prismarine.PrismarineConfig.logPlayerLoginLocation) {
+            PlayerList.LOGGER.info("{}[{}] logged in with entity id {} at ([{}]{}, {}, {})", player.getName().getString(), s1, player.getId(), worldserver1.serverLevelData.getLevelName(), player.getX(), player.getY(), player.getZ());
+        } else {
+            PlayerList.LOGGER.info("{}[{}] logged in with entity id {}", player.getName().getString(), s1, player.getId());
+        }
+        // Prismarine end
     }
 
     public void updateEntireScoreboard(ServerScoreboard scoreboard, ServerPlayer player) {
diff --git a/src/main/java/net/minecraft/util/ClassInstanceMultiMap.java b/src/main/java/net/minecraft/util/ClassInstanceMultiMap.java
index 50a9f33aa31e9273c7c52d4bb2b02f0f884f7ba5..76bb6cc0d28227afd6c0a62c1a13537d8a8c1907 100644
--- a/src/main/java/net/minecraft/util/ClassInstanceMultiMap.java
+++ b/src/main/java/net/minecraft/util/ClassInstanceMultiMap.java
@@ -13,7 +13,7 @@ import java.util.Map;
 import java.util.stream.Collectors;
 
 public class ClassInstanceMultiMap<T> extends AbstractCollection<T> {
-    private final Map<Class<?>, List<T>> byClass = Maps.newHashMap();
+    private final Map<Class<?>, List<T>> byClass = net.prismarineteam.prismarine.PrismarineConfig.useLithiumEntityByType ? new it.unimi.dsi.fastutil.objects.Reference2ReferenceOpenHashMap<>() : Maps.newHashMap(); // Prismarine - JettPack patches (lithium: collections.entity_by_type)
     private final Class<T> baseClass;
     private final List<T> allInstances = Lists.newArrayList();
 
@@ -54,11 +54,32 @@ public class ClassInstanceMultiMap<T> extends AbstractCollection<T> {
         return this.find(object.getClass()).contains(object);
     }
 
+    // Prismarine start - JettPack patches
+    private <S> Collection<T> createAllOfType(Class<S> type) {
+        List<T> list = new java.util.ArrayList<>();
+
+        for (T allElement : this.allInstances) {
+            if (type.isInstance(allElement)) {
+                list.add(allElement);
+            }
+        }
+
+        this.byClass.put(type, list);
+
+        return list;
+    }
+
     public <S> Collection<S> find(Class<S> type) {
+        if (net.prismarineteam.prismarine.PrismarineConfig.useLithiumEntityFiltering) {
+            Collection<T> collection = this.byClass.get(type);
+            if (collection == null) collection = this.createAllOfType(type);
+            return (Collection<S>) Collections.unmodifiableCollection(collection);
+        } else
+    // Prismarine end
         if (!this.baseClass.isAssignableFrom(type)) {
             throw new IllegalArgumentException("Don't know how to search for " + type);
         } else {
-            List<? extends T> list = this.byClass.computeIfAbsent(type, (typeClass) -> {
+            List list = this.byClass.computeIfAbsent(type, (typeClass) -> { // Prismarine - decomp fix
                 return this.allInstances.stream().filter(typeClass::isInstance).collect(Collectors.toList());
             });
             return Collections.unmodifiableCollection(list);
diff --git a/src/main/java/net/minecraft/util/Mth.java b/src/main/java/net/minecraft/util/Mth.java
index 9b22034aa655ceb0da151d9d8ca3147f6487889a..4e0caf5dc8de00066819f40de52ec90559964f65 100644
--- a/src/main/java/net/minecraft/util/Mth.java
+++ b/src/main/java/net/minecraft/util/Mth.java
@@ -25,7 +25,7 @@ public class Mth {
     public static final float EPSILON = 1.0E-5F;
     public static final float SQRT_OF_TWO = sqrt(2.0F);
     private static final float SIN_SCALE = 10430.378F;
-    private static final float[] SIN = Util.make(new float[65536], (sineTable) -> {
+    public static final float[] SIN = Util.make(new float[65536], (sineTable) -> { // Prismarine - private -> public (Jettpack Patches)
         for(int i = 0; i < sineTable.length; ++i) {
             sineTable[i] = (float)Math.sin((double)i * Math.PI * 2.0D / 65536.0D);
         }
@@ -41,10 +41,12 @@ public class Mth {
     private static final double[] COS_TAB = new double[257];
 
     public static float sin(float value) {
+        if (net.prismarineteam.prismarine.PrismarineConfig.useLithiumSine) return me.jellysquid.mods.lithium.common.util.math.CompactSineLUT.sin(value); // Prismarine - JettPack patches (lithium: math.sine_lut)
         return SIN[(int)(value * 10430.378F) & '\uffff'];
     }
 
     public static float cos(float value) {
+        if (net.prismarineteam.prismarine.PrismarineConfig.useLithiumCosine) return me.jellysquid.mods.lithium.common.util.math.CompactSineLUT.cos(value); // Prismarine - JettPack patches (lithium: math.sine_lut)
         return SIN[(int)(value * 10430.378F + 16384.0F) & '\uffff'];
     }
 
diff --git a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
index 7a4ade1a4190bf4fbb048919ae2be230f7b80fff..ab33194cb4d00e033632e753fb131d553dc29d9a 100644
--- a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
+++ b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
@@ -8,6 +8,8 @@ import java.util.Queue;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import java.util.concurrent.locks.LockSupport;
+import java.util.concurrent.LinkedBlockingQueue; // JettPack // Prismarine - JettPack patches
+import java.util.concurrent.TimeUnit; // JettPack // Prismarine - JettPack patches
 import java.util.function.BooleanSupplier;
 import java.util.function.Supplier;
 import net.minecraft.util.profiling.metrics.MetricCategory;
@@ -19,8 +21,9 @@ import org.slf4j.Logger;
 public abstract class BlockableEventLoop<R extends Runnable> implements ProfilerMeasured, ProcessorHandle<R>, Executor {
     private final String name;
     private static final Logger LOGGER = LogUtils.getLogger();
-    private final Queue<R> pendingRunnables = Queues.newConcurrentLinkedQueue();
+    private final LinkedBlockingQueue<R> pendingRunnables = new LinkedBlockingQueue(); // JettPack // Prismarine - JettPack patches
     private int blockingCount;
+    private R next; // JettPack // Prismarine - JettPack patches
 
     protected BlockableEventLoop(String name) {
         this.name = name;
@@ -89,7 +92,7 @@ public abstract class BlockableEventLoop<R extends Runnable> implements Profiler
     @Override
     public void tell(R runnable) {
         this.pendingRunnables.add(runnable);
-        LockSupport.unpark(this.getRunningThread());
+        // LockSupport.unpark(this.getRunningThread()); // JettPack // Prismarine - JettPack patches
     }
 
     @Override
@@ -117,13 +120,20 @@ public abstract class BlockableEventLoop<R extends Runnable> implements Profiler
     }
 
     public boolean pollTask() {
-        R runnable = this.pendingRunnables.peek();
-        if (runnable == null) {
-            return false;
-        } else if (this.blockingCount == 0 && !this.shouldRun(runnable)) {
+        // Prismarine start - JettPack patches
+        if (this.next == null && !this.pendingRunnables.isEmpty()) {
+            this.waitForTasks();
+        }
+
+        if (this.next == null) {
+        // Prismarine end
             return false;
         } else {
-            this.doRunTask(this.pendingRunnables.remove());
+            // Prismarine start - JettPack patches
+            R r2 = this.next;
+            this.next = null;
+            this.doRunTask(r2);
+            // Prismarine end
             return true;
         }
     }
@@ -144,8 +154,18 @@ public abstract class BlockableEventLoop<R extends Runnable> implements Profiler
     }
 
     protected void waitForTasks() {
-        Thread.yield();
-        LockSupport.parkNanos("waiting for tasks", 100000L);
+        // Jettpack start
+        if (this.next != null) {
+            throw new IllegalStateException("next != null");
+        }
+        try {
+            this.next = this.pendingRunnables.poll(100L, TimeUnit.MICROSECONDS);
+            return;
+        }
+        catch (InterruptedException interruptedException) {
+            return;
+        }
+        // Jettpack end
     }
 
     protected void doRunTask(R task) {
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index cd414a9275e6d9f8c704854763b18f4ee43b67b7..61bbb8a3738f289bd61c438a27a496f904c26b78 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -577,11 +577,11 @@ public abstract class LivingEntity extends Entity {
     }
 
     protected void tryAddFrost() {
-        if (!this.getBlockStateOnLegacy().isAir()) {
+        //if (!this.getBlockStateOnLegacy().isAir()) { // Prismarine - JettPack patches (lithium: entity.fast_powder_snow_check)
             int i = this.getTicksFrozen();
 
             if (i > 0) {
-                AttributeInstance attributemodifiable = this.getAttribute(Attributes.MOVEMENT_SPEED);
+                AttributeInstance attributemodifiable = this.getBlockStateOn().isAir() ? null : this.getAttribute(Attributes.MOVEMENT_SPEED); // Prismarine - JettPack patches (lithium: entity.fast_powder_snow_check)
 
                 if (attributemodifiable == null) {
                     return;
@@ -591,7 +591,7 @@ public abstract class LivingEntity extends Entity {
 
                 attributemodifiable.addTransientModifier(new AttributeModifier(LivingEntity.SPEED_MODIFIER_POWDER_SNOW_UUID, "Powder snow slow", (double) f, AttributeModifier.Operation.ADDITION));
             }
-        }
+        //} // Prismarine - JettPack patches (lithium: entity.fast_powder_snow_check)
 
     }
 
@@ -2525,6 +2525,7 @@ public abstract class LivingEntity extends Entity {
     }
 
     protected void updateSwingTime() {
+        if (!this.swinging && this.swingTime == 0) return; // JettPack - lithium: entity.fast_hand_swing
         int i = this.getCurrentSwingDuration();
 
         if (this.swinging) {
diff --git a/src/main/java/net/minecraft/world/entity/Mob.java b/src/main/java/net/minecraft/world/entity/Mob.java
index b75243eca01cae108093368e426ea2d6b6ef1057..a6d022298e2b993f803c4c51bf1543009a8dab2b 100644
--- a/src/main/java/net/minecraft/world/entity/Mob.java
+++ b/src/main/java/net/minecraft/world/entity/Mob.java
@@ -835,9 +835,6 @@ public abstract class Mob extends LivingEntity {
         } else if (!this.isPersistenceRequired() && !this.requiresCustomPersistence()) {
             // Paper start - optimise checkDespawn
             Player entityhuman = this.level.findNearbyPlayer(this, level.paperConfig().entities.spawning.despawnRanges.get(this.getType().getCategory()).hard() + 1, EntitySelector.affectsSpawning); // Paper
-            if (entityhuman == null) {
-                entityhuman = ((ServerLevel)this.level).playersAffectingSpawning.isEmpty() ? null : ((ServerLevel)this.level).playersAffectingSpawning.get(0);
-            }
             // Paper end - optimise checkDespawn
 
             if (entityhuman != null) {
@@ -858,6 +855,9 @@ public abstract class Mob extends LivingEntity {
                     this.noActionTime = 0;
                 }
             }
+            else {
+                this.discard(); // Paper - no entity found on hardDespawnDistance, we should discard it // Prismarine - JettPack patches
+            }
 
         } else {
             this.noActionTime = 0;
diff --git a/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
index 00fc98797aea23e1f586b8e7f85fc27e2019352f..d281138a381a516804eef0da9dabd27e1e92145f 100644
--- a/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
+++ b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
@@ -19,8 +19,8 @@ import org.slf4j.Logger;
 
 public class AttributeMap {
     private static final Logger LOGGER = LogUtils.getLogger();
-    private final Map<Attribute, AttributeInstance> attributes = Maps.newHashMap();
-    private final Set<AttributeInstance> dirtyAttributes = Sets.newHashSet();
+    private final Map<Attribute, AttributeInstance> attributes = net.prismarineteam.prismarine.PrismarineConfig.useLithiumAttributes ? new it.unimi.dsi.fastutil.objects.Reference2ReferenceOpenHashMap<>() : Maps.newHashMap(); // Prismarine - JettPack patches (lithium: collections.attributes)
+    private final Set<AttributeInstance> dirtyAttributes = net.prismarineteam.prismarine.PrismarineConfig.useLithiumAttributes ? new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<>() : Sets.newHashSet(); // Prismarine - JettPack patches (lithium: collections.attributes)
     private final AttributeSupplier supplier;
     private final net.minecraft.world.entity.LivingEntity entity; // Purpur
     private final java.util.function.Function<Attribute, AttributeInstance> createInstance; // Pufferfish
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java b/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
index 872ec431ae6beb0ef603d833f38aedb9d87e5466..59014e55a6848addfd67cfc2bc0366e313c0145d 100644
--- a/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
@@ -27,7 +27,7 @@ public class GoalSelector {
         }
     };
     private final Map<Goal.Flag, WrappedGoal> lockedFlags = new EnumMap<>(Goal.Flag.class);
-    public final Set<WrappedGoal> availableGoals = Sets.newLinkedHashSet();
+    public final Set<WrappedGoal> availableGoals = new it.unimi.dsi.fastutil.objects.ObjectLinkedOpenHashSet<>(); // JettPack - lithium: replace AI goal set with optimized collection // Prismarine - JettPack patches
     private final Supplier<ProfilerFiller> profiler;
     private final EnumSet<Goal.Flag> disabledFlags = EnumSet.noneOf(Goal.Flag.class); // Paper unused, but dummy to prevent plugins from crashing as hard. Theyll need to support paper in a special case if this is super important, but really doesn't seem like it would be.
     private final com.destroystokyo.paper.util.set.OptimizedSmallEnumSet<net.minecraft.world.entity.ai.goal.Goal.Flag> goalTypes = new com.destroystokyo.paper.util.set.OptimizedSmallEnumSet<>(Goal.Flag.class); // Paper - remove streams from pathfindergoalselector
diff --git a/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java b/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
index f5886a88fd98ede5e85a91eccccb05ac33eb40e2..b4403229fb9ff45410b63d2d1459f9cb5c56cd5e 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
@@ -264,7 +264,7 @@ public class FishingHook extends Projectile {
         boolean flag = itemstack.is(Items.FISHING_ROD);
         boolean flag1 = itemstack1.is(Items.FISHING_ROD);
 
-        if (!player.isRemoved() && player.isAlive() && (flag || flag1) && this.distanceToSqr((Entity) player) <= 1024.0D) {
+        if (!player.isRemoved() && player.isAlive() && (flag || flag1) && this.distanceToSqr((Entity) player) <= player.getLevel().prismarineConfig.fishingRodLength) { // Prismarine - JettPack patches
             return false;
         } else {
             this.discard();
diff --git a/src/main/java/net/minecraft/world/item/crafting/Ingredient.java b/src/main/java/net/minecraft/world/item/crafting/Ingredient.java
index 809c6531d056cc9538e9bec9cdc5ca6e4c9f4792..1e1147f40ea27a676756eb7f9fd6b175e07cb13b 100644
--- a/src/main/java/net/minecraft/world/item/crafting/Ingredient.java
+++ b/src/main/java/net/minecraft/world/item/crafting/Ingredient.java
@@ -14,7 +14,10 @@ import java.util.Collection;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Set; // Prismarine - JettPack patches (VMP: ingredient matching cache)
+import java.util.HashSet; // Prismarine - JettPack patches (VMP: ingredient matching cache)
 import java.util.function.Predicate;
+import java.util.stream.Collectors; // Prismarine - JettPack patches (VMP: ingredient matching cache)
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 import javax.annotation.Nullable;
@@ -38,6 +41,8 @@ public final class Ingredient implements Predicate<ItemStack> {
     @Nullable
     private IntList stackingIds;
     public boolean exact; // CraftBukkit
+    private Set<Item> matchingItems = null; // Prismarine - JettPack patches (VMP: ingredient matching cache)
+    private boolean isEmptyMatch = false; // Prismarine - JettPack patches (VMP: ingredient matching cache)
     public Predicate<org.bukkit.inventory.ItemStack> predicate;
 
     public Ingredient(Stream<? extends Ingredient.Value> entries) {
@@ -70,6 +75,7 @@ public final class Ingredient implements Predicate<ItemStack> {
         if (itemstack == null) {
             return false;
         } else {
+            /* // Prismarine - JettPack patches (VMP: ingredient matching cache)
             this.dissolve();
             if (this.itemStacks.length == 0) {
                 return itemstack.isEmpty();
@@ -102,6 +108,23 @@ public final class Ingredient implements Predicate<ItemStack> {
 
                 return false;
             }
+             */ // Prismarine - JettPack patches (VMP: ingredient matching cache)
+            // Prismarine start - JettPack patches (VMP: ingredient matching cache)
+            Set<Item> matchingItems = this.matchingItems;
+            boolean isEmptyMatch = this.isEmptyMatch;
+            if (matchingItems == null) {
+                matchingItems = this.matchingItems = Arrays.stream(this.values)
+                        .flatMap(entry -> entry.getItems().stream())
+                        .filter(itemstack1 -> !itemstack1.isEmpty())
+                        .map(ItemStack::getItem)
+                        .collect(Collectors.toCollection(HashSet::new));
+                isEmptyMatch = this.isEmptyMatch = this.matchingItems.isEmpty();
+            }
+            if (itemstack.isEmpty()) {
+                return isEmptyMatch;
+            }
+            return matchingItems.contains(itemstack.getItem());
+            // Prismarine end
         }
     }
 
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 25c8294a36d2f062ca4882820e99315aabf5dde8..2b0f8f1c4b31ab80a8b118f6b4598d1eb26ed802 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -117,9 +117,9 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public static final int TICKS_PER_DAY = 24000;
     public static final int MAX_ENTITY_SPAWN_Y = 20000000;
     public static final int MIN_ENTITY_SPAWN_Y = -20000000;
-    protected final List<TickingBlockEntity> blockEntityTickers = Lists.newArrayList(); public final int getTotalTileEntityTickers() { return this.blockEntityTickers.size(); } // Paper
+    protected final List<TickingBlockEntity> blockEntityTickers = me.jellysquid.mods.lithium.common.util.collections.HashedList.wrapper(Lists.newArrayList()); public final int getTotalTileEntityTickers() { return this.blockEntityTickers.size(); } // Paper // Jettpack - lithium: hashed_list // Prismarine - JettPack patches
     protected final NeighborUpdater neighborUpdater;
-    private final List<TickingBlockEntity> pendingBlockEntityTickers = Lists.newArrayList();
+    private final List<TickingBlockEntity> pendingBlockEntityTickers = me.jellysquid.mods.lithium.common.util.collections.HashedList.wrapper(Lists.newArrayList()); // Jettpack - lithium: hashed_list // Prismarine - JettPack patches
     private boolean tickingBlockEntities;
     public final Thread thread;
     private final boolean isDebug;
diff --git a/src/main/java/net/minecraft/world/level/block/Block.java b/src/main/java/net/minecraft/world/level/block/Block.java
index ce4127f3701efa7d1c86bcdb4e7804fee11c397c..9d801652d1ccdb356f26f914824a2b46b1e8e9b6 100644
--- a/src/main/java/net/minecraft/world/level/block/Block.java
+++ b/src/main/java/net/minecraft/world/level/block/Block.java
@@ -669,11 +669,13 @@ public class Block extends BlockBehaviour implements ItemLike {
         private final BlockState first;
         private final BlockState second;
         private final Direction direction;
+        private int hash; // Prismarine - JettPack patches (lithium: cached_hashcode)
 
         public BlockStatePairKey(BlockState self, BlockState other, Direction facing) {
             this.first = self;
             this.second = other;
             this.direction = facing;
+            this.hash = 31 * (31 * this.first.hashCode() + this.second.hashCode()) + this.direction.hashCode(); // Prismarine - JettPack patches (lithium: cached_hashcode)
         }
 
         public boolean equals(Object object) {
@@ -689,11 +691,7 @@ public class Block extends BlockBehaviour implements ItemLike {
         }
 
         public int hashCode() {
-            int i = this.first.hashCode();
-
-            i = 31 * i + this.second.hashCode();
-            i = 31 * i + this.direction.hashCode();
-            return i;
+            return this.hash; // Prismarine - JettPack patches (lithium: cached_hashcode)
         }
     }
 }
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
index 0c648611658c4c1fae08e867c3090c7d0241a189..9da7c6b4e3a3c8127089218a1e811c23ff27734e 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
@@ -113,7 +113,7 @@ public class RegionFileStorage implements AutoCloseable {
 
     // Paper start
     private static void printOversizedLog(String msg, Path file, int x, int z) {
-        org.apache.logging.log4j.LogManager.getLogger().fatal(msg + " (" + file.toString().replaceAll(".+[\\\\/]", "") + " - " + x + "," + z + ") Go clean it up to remove this message. /minecraft:tp " + (x<<4)+" 128 "+(z<<4) + " - DO NOT REPORT THIS TO PRISMARINE - You may ask for help on Discord, but do not file an issue. These error messages can not be removed."); // Purpur // Prismarine
+        net.minecraft.server.MinecraftServer.LOGGER.error(com.mojang.logging.LogUtils.FATAL_MARKER, msg + " (" + file.toString().replaceAll(".+[\\\\/]", "") + " - " + x + "," + z + ") Go clean it up to remove this message. /minecraft:tp " + (x<<4)+" 128 "+(z<<4) + " - DO NOT REPORT THIS TO PRISMARINE - You may ask for help on Discord, but do not file an issue. These error messages can not be removed."); // Purpur // Prismarine - JettPack patches (Remove unnecessary getLogger())
     }
 
     private static final int DEFAULT_SIZE_THRESHOLD = 1024 * 8;
diff --git a/src/main/java/net/minecraft/world/level/entity/EntitySectionStorage.java b/src/main/java/net/minecraft/world/level/entity/EntitySectionStorage.java
index f54ca6383298848b2ee7108c41fcea593f924881..3f620efec7af845532d5562403e06971134b17f5 100644
--- a/src/main/java/net/minecraft/world/level/entity/EntitySectionStorage.java
+++ b/src/main/java/net/minecraft/world/level/entity/EntitySectionStorage.java
@@ -32,34 +32,66 @@ public class EntitySectionStorage<T extends EntityAccess> {
         this.intialSectionVisibility = chunkStatusDiscriminator;
     }
 
+    // Prismarine start - JettPack patches (lithium: entity.fast_retrieval)
     public void forEachAccessibleNonEmptySection(AABB box, Consumer<EntitySection<T>> action) {
-        int i = 2;
-        int j = SectionPos.posToSectionCoord(box.minX - 2.0D);
-        int k = SectionPos.posToSectionCoord(box.minY - 4.0D);
-        int l = SectionPos.posToSectionCoord(box.minZ - 2.0D);
-        int m = SectionPos.posToSectionCoord(box.maxX + 2.0D);
-        int n = SectionPos.posToSectionCoord(box.maxY + 0.0D);
-        int o = SectionPos.posToSectionCoord(box.maxZ + 2.0D);
-
-        for(int p = j; p <= m; ++p) {
-            long q = SectionPos.asLong(p, 0, 0);
-            long r = SectionPos.asLong(p, -1, -1);
-            LongIterator longIterator = this.sectionIds.subSet(q, r + 1L).iterator();
-
-            while(longIterator.hasNext()) {
-                long s = longIterator.nextLong();
-                int t = SectionPos.y(s);
-                int u = SectionPos.z(s);
-                if (t >= k && t <= n && u >= l && u <= o) {
-                    EntitySection<T> entitySection = this.sections.get(s);
-                    if (entitySection != null && !entitySection.isEmpty() && entitySection.getStatus().isAccessible()) {
-                        action.accept(entitySection);
+        int minX = SectionPos.posToSectionCoord(box.minX - 2.0D);
+        int minY = SectionPos.posToSectionCoord(box.minY - 2.0D);
+        int minZ = SectionPos.posToSectionCoord(box.minZ - 2.0D);
+        int maxX = SectionPos.posToSectionCoord(box.maxX + 2.0D);
+        int maxY = SectionPos.posToSectionCoord(box.maxY + 2.0D);
+        int maxZ = SectionPos.posToSectionCoord(box.maxZ + 2.0D);
+
+        if (maxX >= minX + 4 || maxZ >= minZ + 4) {
+            // [VanillaCopy]
+            for(int o = minX; o <= maxX; ++o) {
+                long p = SectionPos.asLong(o, 0, 0);
+                long q = SectionPos.asLong(o, -1, -1);
+                LongIterator longIterator = this.sectionIds.subSet(p, q + 1L).iterator();
+
+                while(longIterator.hasNext()) {
+                    long r = longIterator.nextLong();
+                    int s = SectionPos.y(r);
+                    int t = SectionPos.z(r);
+                    if (s >= minY && s <= maxY && t >= minZ && t <= maxZ) {
+                        EntitySection<T> entitySection = this.sections.get(r);
+                        if (entitySection != null && !entitySection.isEmpty() && entitySection.getStatus().isAccessible()) {
+                            action.accept(entitySection);
+                        }
                     }
                 }
             }
+        } else {
+            for (int x = minX; x <= maxX; x++) {
+                for (int z = Math.max(minZ, 0); z <= maxZ; z++) {
+                    this.forEachInColumn(x, minY, maxY, z, action);
+                }
+
+                int bound = Math.min(-1, maxZ);
+                for (int z = minZ; z <= bound; z++) {
+                    this.forEachInColumn(x, minY, maxY, z, action);
+                }
+            }
         }
+    }
 
+    private void forEachInColumn(int x, int minY, int maxY, int z, Consumer<EntitySection<T>> action) {
+        //y from negative to positive, but y is treated as unsigned
+        for (int y = Math.max(minY, 0); y <= maxY; y++) {
+            this.consumeSection(SectionPos.asLong(x, y, z), action);
+        }
+        int bound = Math.min(-1, maxY);
+        for (int y = minY; y <= bound; y++) {
+            this.consumeSection(SectionPos.asLong(x, y, z), action);
+        }
+    }
+
+    private void consumeSection(long pos, Consumer<EntitySection<T>> action) {
+        EntitySection<T> section = this.getSection(pos);
+        if (section != null && 0 != section.size() && section.getStatus().isAccessible()) {
+            action.accept(section);
+        }
     }
+    // Prismarine end
 
     public LongStream getExistingSectionPositionsInChunk(long chunkPos) {
         int i = ChunkPos.getX(chunkPos);
diff --git a/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java b/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java
index 2bb24bf628a37c79e337f1cba99b816465ecb723..f5a877126db1b772f44136ffc2a9740b57ef6d88 100644
--- a/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java
+++ b/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java
@@ -24,6 +24,7 @@ public class PlayerDataStorage {
     private static final Logger LOGGER = LogUtils.getLogger();
     private final File playerDir;
     protected final DataFixer fixerUpper;
+    private final me.titaniumtown.cache.NBTCache dataCache = new me.titaniumtown.cache.NBTCache(); // JettPack - NBT Cache system
 
     public PlayerDataStorage(LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer) {
         this.fixerUpper = dataFixer;
@@ -37,11 +38,27 @@ public class PlayerDataStorage {
             CompoundTag nbttagcompound = player.saveWithoutId(new CompoundTag());
             File file = File.createTempFile(player.getStringUUID() + "-", ".dat", this.playerDir);
 
-            NbtIo.writeCompressed(nbttagcompound, file);
-            File file1 = new File(this.playerDir, player.getStringUUID() + ".dat");
-            File file2 = new File(this.playerDir, player.getStringUUID() + ".dat_old");
+            // Prismarine start - JettPack patches
+            Runnable task = () -> {
+                try {
+                    NbtIo.writeCompressed(nbttagcompound, file);
+                    File file1 = new File(this.playerDir, player.getStringUUID() + ".dat");
+                    File file2 = new File(this.playerDir, player.getStringUUID() + ".dat_old");
 
-            Util.safeReplaceFile(file1, file, file2);
+                    Util.safeReplaceFile(file1, file, file2);
+                } catch (Exception exception) {
+                    LOGGER.error("Failed to save player data for {}", player.getName(), exception);
+                }
+            };
+            synchronized (this.dataCache) {
+                this.dataCache.put(file, nbttagcompound);
+            }
+            if (net.prismarineteam.prismarine.PrismarineConfig.useYatopiaAsyncNBTCache) {
+                net.minecraft.server.MCUtil.asyncExecutor.execute(task);
+            } else {
+                task.run();
+            }
+            // Prismarine end
         } catch (Exception exception) {
             PlayerDataStorage.LOGGER.warn("Failed to save player data for {}", player.getScoreboardName(), exception); // Paper
         }
@@ -57,9 +74,20 @@ public class PlayerDataStorage {
             // Spigot Start
             boolean usingWrongFile = false;
             boolean normalFile = file.exists() && file.isFile(); // Akarin - ensures normal file // Prismarine - Akarin patches
-            if ( org.bukkit.Bukkit.getOnlineMode() && !normalFile ) // Paper - Check online mode first // Akarin - ensures normal file // Prismarine - Akarin patches
+            // Prismarine start - JettPack patches
+            CompoundTag playerData;
+            synchronized (this.dataCache) {
+                playerData = this.dataCache.get(file);
+            }
+            if ( playerData == null && org.bukkit.Bukkit.getOnlineMode() && !normalFile ) // Paper - Check online mode first // Akarin - ensures normal file // Prismarine - Akarin patches
+            // Prismarine end
             {
                 file = new File( this.playerDir, java.util.UUID.nameUUIDFromBytes( ( "OfflinePlayer:" + player.getScoreboardName() ).getBytes( "UTF-8" ) ).toString() + ".dat");
+                // Prismarne start - JettPack patches
+                synchronized (this.dataCache) {
+                    playerData = this.dataCache.get(file);
+                }
+                // Prismarine end
                 if ( file.exists() )
                 {
                     usingWrongFile = true;
@@ -68,6 +96,11 @@ public class PlayerDataStorage {
             }
             // Spigot End
 
+            // Prismarine start - JettPack patches
+            if (playerData != null) {
+                nbttagcompound = playerData;
+            } else
+            // Prismarine end
             if (normalFile) { // Akarin - ensures normal file // Prismarine - Akarin patches
                 nbttagcompound = NbtIo.readCompressed(file);
             }
diff --git a/src/main/java/net/minecraft/world/phys/AABB.java b/src/main/java/net/minecraft/world/phys/AABB.java
index cfb2e46b34b2982d6724f18214557fc80cf4adfa..07b0d7a4dcac08b68099b5e1c26675c3ad460e94 100644
--- a/src/main/java/net/minecraft/world/phys/AABB.java
+++ b/src/main/java/net/minecraft/world/phys/AABB.java
@@ -16,6 +16,15 @@ public class AABB {
     public final double maxY;
     public final double maxZ;
 
+    // Prismarine start - JettPack patches (lithium: fast_util)
+    static {
+        assert Direction.Axis.X.ordinal() == 0;
+        assert Direction.Axis.Y.ordinal() == 1;
+        assert Direction.Axis.Z.ordinal() == 2;
+        assert Direction.Axis.values().length == 3;
+    }
+    // Prismarine ned
+
     public AABB(double x1, double y1, double z1, double x2, double y2, double z2) {
         this.minX = Math.min(x1, x2);
         this.minY = Math.min(y1, y2);
@@ -81,11 +90,31 @@ public class AABB {
     }
 
     public double min(Direction.Axis axis) {
-        return axis.choose(this.minX, this.minY, this.minZ);
+        // Prismarine start - JettPack patches (lithium: fast_util)
+        switch (axis.ordinal()) {
+            case 0:
+                return this.minX;
+            case 1:
+                return this.minY;
+            case 2:
+                return this.minZ;
+        }
+        throw new IllegalArgumentException();
+        // Prismarine end
     }
 
     public double max(Direction.Axis axis) {
-        return axis.choose(this.maxX, this.maxY, this.maxZ);
+        // Prismarine start - JettPack patches (lithium: fast_util)
+        switch (axis.ordinal()) {
+            case 0:
+                return this.minX;
+            case 1:
+                return this.minY;
+            case 2:
+                return this.minZ;
+        }
+        throw new IllegalArgumentException();
+        // Prismarine end
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/phys/shapes/CubePointRange.java b/src/main/java/net/minecraft/world/phys/shapes/CubePointRange.java
index a544db042c8d2ecec8d323770552c4f10ca758a6..c04da8da5b40430b61972bce32cec4e8c0370bac 100644
--- a/src/main/java/net/minecraft/world/phys/shapes/CubePointRange.java
+++ b/src/main/java/net/minecraft/world/phys/shapes/CubePointRange.java
@@ -4,6 +4,7 @@ import it.unimi.dsi.fastutil.doubles.AbstractDoubleList;
 
 public class CubePointRange extends AbstractDoubleList {
     private final int parts;
+    private double scale; // JettPack - lithium: shapes.precompute_shape_arrays
 
     CubePointRange(int sectionCount) {
         if (sectionCount <= 0) {
@@ -11,10 +12,11 @@ public class CubePointRange extends AbstractDoubleList {
         } else {
             this.parts = sectionCount;
         }
+        this.scale = 1.0D / sectionCount; // JettPack - lithium: shapes.precompute_shape_arrays
     }
 
     public double getDouble(int i) {
-        return (double)i / (double)this.parts;
+        return i * this.scale; // JettPack - lithium: shapes.precompute_shape_arrays
     }
 
     public int size() {
diff --git a/src/main/java/net/minecraft/world/phys/shapes/CubeVoxelShape.java b/src/main/java/net/minecraft/world/phys/shapes/CubeVoxelShape.java
index 68e89dbd79171627046e89699057964e44c40e7d..959588962acb0196ec9f1cc2502e62117f6ccdc4 100644
--- a/src/main/java/net/minecraft/world/phys/shapes/CubeVoxelShape.java
+++ b/src/main/java/net/minecraft/world/phys/shapes/CubeVoxelShape.java
@@ -3,15 +3,25 @@ package net.minecraft.world.phys.shapes;
 import it.unimi.dsi.fastutil.doubles.DoubleList;
 import net.minecraft.core.Direction;
 import net.minecraft.util.Mth;
+import net.minecraft.world.phys.shapes.CubePointRange; // JettPack
 
 public final class CubeVoxelShape extends VoxelShape {
+    private DoubleList[] list; // JettPack - lithium: shapes.precompute_shape_arrays
+
     protected CubeVoxelShape(DiscreteVoxelShape voxels) {
         super(voxels);
+        // JettPack start - lithium: shapes.precompute_shape_arrays
+        this.list = new DoubleList[Direction.VALUES.length];
+
+        for (Direction.Axis axis : Direction.Axis.VALUES) {
+            this.list[axis.ordinal()] = new CubePointRange(voxels.getSize(axis));
+        }
+        // JettPack end
     }
 
     @Override
     protected DoubleList getCoords(Direction.Axis axis) {
-        return new CubePointRange(this.shape.getSize(axis));
+        return this.list[axis.ordinal()]; // JettPack - lithium: shapes.precompute_shape_arrays
     }
 
     @Override
diff --git a/src/main/java/net/prismarineteam/prismarine/PrismarineConfig.java b/src/main/java/net/prismarineteam/prismarine/PrismarineConfig.java
index eb01aab61aa3383e39120c7dfb60d9c9a4b801d1..7ff0d6ca8fcd4c9c5692647fe602512cb31ad65b 100644
--- a/src/main/java/net/prismarineteam/prismarine/PrismarineConfig.java
+++ b/src/main/java/net/prismarineteam/prismarine/PrismarineConfig.java
@@ -154,4 +154,45 @@ public class PrismarineConfig {
             set("settings.patina-settings.disable-bootstrap-executor", null);
         }
     }
+
+    public static boolean useJettPackAsyncExecutor = true;
+    private static void JettPackPatches() {
+        useJettPackAsyncExecutor = getBoolean("settings.use-jettpack-async-executor", useJettPackAsyncExecutor);
+        if (version < 3) {
+            set("settings.use-jettpack-async-executor", getBoolean("settings.jettpack-patches.use-jettpack-async-executor", true));
+            set("settings.jettpack-patches.use-jettpack-async-executor", null);
+        }
+    }
+
+    public static boolean useYatopiaAsyncNBTCache = false;
+    private static void useYatopiaAsyncNBTCache() {
+        useYatopiaAsyncNBTCache = getBoolean("settings.use-yatopia-async-nbt-cache", useYatopiaAsyncNBTCache);
+        if (version < 3) {
+            set("settings.use-yatopia-async-nbt-cache", getBoolean("settings.jettpack-patches.use-yatopia-async-nbt-cache", false));
+            set("settings.jettpack-patches.use-yatopia-async-nbt-cache", null);
+        }
+    }
+
+    public static boolean logPlayerLoginLocation = true;
+    private static void logPlayerLoginLocation() {
+        logPlayerLoginLocation = getBoolean("settings.log-player-login-location", logPlayerLoginLocation);
+    }
+
+    public static boolean useLithiumCosine = true;
+    public static boolean useLithiumSine = true;
+    public static boolean useLithiumAttributes = true;
+    public static boolean useLithiumEntityByType = true;
+    public static boolean useLithiumEntityFiltering = true;
+    private static void useLithiumMath() {
+        useLithiumCosine = getBoolean("settings.lithium.math.cosine", useLithiumCosine);
+        useLithiumSine = getBoolean("settings.lithium.math.sine", useLithiumSine);
+        useLithiumAttributes = getBoolean("settings.lithium.attributes", useLithiumAttributes);
+        useLithiumEntityByType = getBoolean("settings.lithium.collections.entity_by_type", useLithiumEntityByType);
+        useLithiumEntityFiltering = getBoolean("settings.lithium.collections.entity_filtering", useLithiumEntityFiltering);
+    }
+
+    public static boolean fastHandSwing = true;
+    private static void fastHandSwing() {
+        fastHandSwing = getBoolean("settings.fast-hand-swing", fastHandSwing);
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/net/prismarineteam/prismarine/PrismarineWorldConfig.java b/src/main/java/net/prismarineteam/prismarine/PrismarineWorldConfig.java
index cf494171713b5fc12e9627774f2705b911b54bd2..c66135f75f95a10dd49cfb67ed8d84317715193d 100644
--- a/src/main/java/net/prismarineteam/prismarine/PrismarineWorldConfig.java
+++ b/src/main/java/net/prismarineteam/prismarine/PrismarineWorldConfig.java
@@ -74,4 +74,9 @@ public class PrismarineWorldConfig {
         final Map<String, Object> value = PrismarineConfig.getMap("world-settings." + worldName + "." + path, null);
         return value.isEmpty() ? fallback : value;
     }
+    
+    public double fishingRodLength = 1024.0D;
+    private void fishingRodLength() {
+        fishingRodLength = getDouble("fishing-rod-length", fishingRodLength);
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftAsyncScheduler.java b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftAsyncScheduler.java
index 9c1aff17aabd062640e3f451a2ef8c50a7c62f10..f8b36ea1249d3444d25ac88748437aa999171ac6 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftAsyncScheduler.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftAsyncScheduler.java
@@ -38,17 +38,21 @@ import java.util.concurrent.TimeUnit;
 
 public class CraftAsyncScheduler extends CraftScheduler {
 
+    /* // Prismarine - JettPack patches
     private final ThreadPoolExecutor executor = new ThreadPoolExecutor(
             4, Integer.MAX_VALUE,30L, TimeUnit.SECONDS, new SynchronousQueue<>(),
             new ThreadFactoryBuilder().setNameFormat("Craft Scheduler Thread - %1$d").setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(net.minecraft.server.MinecraftServer.LOGGER)).build()); // Paper
+    */ // Prismarine - JettPack patches
     private final Executor management = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder()
             .setNameFormat("Craft Async Scheduler Management Thread").setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(net.minecraft.server.MinecraftServer.LOGGER)).build()); // Paper
     private final List<CraftTask> temp = new ArrayList<>();
 
     CraftAsyncScheduler() {
         super(true);
+        /* // Prismarine - JettPack patches
         executor.allowCoreThreadTimeOut(true);
         executor.prestartAllCoreThreads();
+         */ // Prismarine - JettPack patches
     }
 
     @Override
@@ -93,7 +97,7 @@ public class CraftAsyncScheduler extends CraftScheduler {
     private boolean executeTask(CraftTask task) {
         if (isValid(task)) {
             this.runners.put(task.getTaskId(), task);
-            this.executor.execute(new ServerSchedulerReportingWrapper(task));
+            net.minecraft.server.MCUtil.asyncExecutor.execute(new ServerSchedulerReportingWrapper(task)); // Jettpack // Prismarine - JettPack patches
             return true;
         }
         return false;
diff --git a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
index 2d90a7cf5d5de95005724fabcf7362bf7b555f6e..72ed3ff31682673c045be76bf5329894704b84d0 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
@@ -8,8 +8,11 @@ import java.util.logging.Logger;
 import org.bukkit.Bukkit;
 
 public final class Versioning {
-    public static String getBukkitVersion() {
-        String result = "Unknown-Version";
+    // Prismarine start - JettPack patches
+    public static String bukkitVersion;
+    static {
+        bukkitVersion = "Unknown-Version";
+    // Prismarine end
 
         InputStream stream = Bukkit.class.getClassLoader().getResourceAsStream("META-INF/maven/net.prismarineteam.prismarine/Prismarine-API/pom.properties"); // Purpur // Prismarine
         Properties properties = new Properties();
@@ -18,12 +21,16 @@ public final class Versioning {
             try {
                 properties.load(stream);
 
-                result = properties.getProperty("version");
+                bukkitVersion = properties.getProperty("version"); // Prismarine - JettPack patches
             } catch (IOException ex) {
                 Logger.getLogger(Versioning.class.getName()).log(Level.SEVERE, "Could not get Prismarine version!", ex); // Prismarine
             }
         }
+    }
 
-        return result;
+    // Prismarine start - JettPack patches
+    public static String getBukkitVersion() {
+        return bukkitVersion;
     }
+    // Prismarine end
 }
diff --git a/src/main/java/org/spigotmc/WatchdogThread.java b/src/main/java/org/spigotmc/WatchdogThread.java
index af61231d5b76690f32ec51feae343909ecc5b0b6..c37de3ca2bdf3b9dfb92b8585015cb94eefef843 100644
--- a/src/main/java/org/spigotmc/WatchdogThread.java
+++ b/src/main/java/org/spigotmc/WatchdogThread.java
@@ -140,7 +140,7 @@ public class WatchdogThread extends Thread
     {
         while ( !this.stopping )
         {
-            //
+            net.minecraft.server.MCUtil.flushAsyncTasks(); // Jettpack // Prismarine - JettPack patches
             // Paper start
             Logger log = Bukkit.getServer().getLogger();
             long currentTime = WatchdogThread.monotonicMillis();
